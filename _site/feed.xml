<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-17T13:09:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jake Kim</title><author><name>Jake Kim</name></author><entry><title type="html">OKE-Basic</title><link href="http://localhost:4000/oke/kubernetes/OKE-basic/" rel="alternate" type="text/html" title="OKE-Basic" /><published>2020-01-10T15:12:00+09:00</published><updated>2020-01-10T15:12:00+09:00</updated><id>http://localhost:4000/oke/kubernetes/OKE-basic</id><content type="html" xml:base="http://localhost:4000/oke/kubernetes/OKE-basic/">&lt;h1 id=&quot;oracle-kubernetes&quot;&gt;Oracle Kubernetes&lt;/h1&gt;
&lt;p&gt;OKE 는 Oracle Kubernetes Engine 으로 Managed Kubernetes 로 별도 설치할 필요 없이 편리하게 사용 할 수 있다는 장점을 제공 한다. 특히 Kubernetes Master 가 3개로 설치 되어 장애 등에 대비 할 수 있는 것이 장점이다. 글을 쓰지 시점에는 지원 되는 버전이 1.14.8, 1.13.5, 1.12.7 이 제공 되고 있다.
별도로 Kubernetes 를 설치 하기 번거롭다면 OKE 를 이용하여 충분히 Kubernetes 를 공부해 볼 수 있다.
OKE 를 구성 하려면 Oracle Cloud 에 로그인 하여 Developer Service 에서 cluster 를 선택 하면 된다.
&lt;img src=&quot;/image/kubernetes/kubernetes-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Create Cluster 를 클릭 하면 Quick Create 와 Custom Create 옵션이 있다. 네트워크 구성 및 노드 구성을 자동으로 구성 하기 위해 Quick Create 를 선택 하여 준다. 이후 입력 사항은 클러스터의 이름과 Kubernetes 의 버젼, Worker Node 의 네트워크 구성 만 선택 하면 된다. Private 으로 하는 경우 Worker Node 에 Public IP 가 부여 되지 않아 Host 에 직접 접근이 불가능 하다. 그러나 Worker Node 에 대한 보안 측면을 본다면 Private 로 하는 것이 맞으며 Node 접근이 많이 필요 하지 않음으로 Private 로 하면 된다. Shape 와 Node 의 개수는 테스트를 위한 것임으로 VM.Standard.E2.1 로 3 개의 노드를 선택 하도록 하겠다. 리뷰 화면에서는 네트워크 이름과 Pods 에 부여된 네트워크 CIDR 을 볼 수 있다.
&lt;img src=&quot;/image/kubernetes/kubernetes-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성 버튼을 누르면 Kubernetes Cluster 가 생성 된다.
생성이 완료 되면 Developer Service &amp;gt; Container Cluster 를 들어가 보면 생성된 클러스터와 상태를 볼 수 있다. 생성한 클러스터를 클릭 해 보면 상세한 Kubernetes 의 정보를 볼 수 있다.
이제 Kubernetes 를 관리 하기 위한 Kubectl 을 설치 하여 보자.
순서는 OCICLI 설치, Kubectl 설치로 나뉠수 있다.&lt;/p&gt;

&lt;h1 id=&quot;oci-cli-install&quot;&gt;OCI cli Install&lt;/h1&gt;
&lt;p&gt;사전에 오라클 클라우드 관리 툴인 OCICli 가 설치 되어 있다면 Kubectl 을 바로 설치 하여 주면 된다. 그렇지 않다면 다음 순서로 설치 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MacOS, Linux 환경&lt;/p&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;python3  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
  &lt;p&gt;&lt;img src=&quot;/image/kubernetes/kubernetes-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;설치 경로 및 ocicli 명령어를 Path 넣기 위한 사용자 입력이 필요하며 기본값과 Y 를 선택 하면 된다.
설치 완료 후 oci –version 을 실행 하면 버전 정보를 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Windows 환경&lt;br /&gt;
Powershell 을 Run as Administrator 옵션으로 실행 하여 준다.&lt;/p&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Set-ExecutionPolicy RemoteSigned  
powershell &lt;span class=&quot;nt&quot;&gt;-NoProfile&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ExecutionPolicy&lt;/span&gt; Bypass &lt;span class=&quot;nt&quot;&gt;-Command&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.ps1'))&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
  &lt;p&gt;MacOS, Linux 와 마찬가지로 설치되는 경로를 지정 하는 과정이 나온다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;oci-cli-config&quot;&gt;OCI cli config&lt;/h1&gt;
&lt;p&gt;다음 과정은 OCI cli 와 사용하고 있는 클라우드 서비스와 연결을 위한 설정이 필요 하다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;macOS, Linux&lt;/p&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;oci setup config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
  &lt;p&gt;설치 과정에서 연결을 위한 보안 정보 등이 .oci/config 파일에 저장 된다. 설정 과정은 config 이 저장될 경로 및 User OCID, tenancy OCID, Datacenter 등을 입력 하여야 한다. 
User OCID 는 identity &amp;gt; Users 에서 사용자를 선택 하면 User Information 에서 볼 수 있다&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-4.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Tenancy OCI 는 Administration &amp;gt; tenancy detail 에서 볼 수 있다.&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-5.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;
인증서를 이용한 연결을 위해 Private key 와 Public key 가 생성이 된다. 특별한 이유가 없으면 기본 이름을 사용하여 생성 하면 비대칭 키가 자동 생성 된다. OCI 에 사용자에 public key 를 인증키로 등록 하여 주면 설정이 완료 된다. identity &amp;gt; Users 에서 사용자를 선택 한 후 API Keys 에서 Add Public Key 를 클릭 하여 Public key 를 등록 하여 주면 된다.
&lt;img src=&quot;/image/kubernetes/kubernetes-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;설정이 완료 되었으면 다음 명령어를 실행 하면 Tenancy 이름이 반환 되는 것을 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;oci os ns get  
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;s2&quot;&gt;&quot;data&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;*****&quot;&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;kubectl-install&quot;&gt;Kubectl install&lt;/h1&gt;
&lt;p&gt;oci 설치가 완료되었으며 Kubernetes 관리를 위한 client 툴을 설치하여야 한다. 설치는 다음 문서를 참조 한다
&lt;a href=&quot;https://kubernetes.io/docs/tasks/tools/install-kubectl/&quot;&gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/&lt;/a&gt;
Linux 나 MacOS 에서는 다음과 같이 설치 하여 준다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$ curl -L0 https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl&lt;br /&gt;
$ chmod +x ./kubectl&lt;br /&gt;
$ sudo mv ./kubectl /usr/local/bin/kubectl&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OKE 와 kubectl 과 연결을 위해 생성한 OKE cluster 의 OCID 가 필요 하다. 생성한 cluster 의 상세 정보에서 OCID 를 찾을 수 있다.
등록 과정은 다음과 같이 .kube 폴더를 생성 하고 설정 파일을 만드는 과정이다&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$ mkdir -p $HOME/.kube&lt;br /&gt;
$ oci ce cluster create-kubeconfig –cluster-id &lt;strong&gt;Cluster_OCID&lt;/strong&gt; –file $HOME/.kube/config –region us-ashburn-1 –token-version 2.0.0&lt;br /&gt;
&lt;strong&gt;Cluster_OCID&lt;/strong&gt; 으로 표기된 부분에 cluster 의 OCID 를 복사하여 주고 region 에는 생성한 cluster 의 지역을 입력 하여 준다.&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;설정이 완료 되었으면 다음 명령어로 cluster 내의 node 정보를 가져와 보도록 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get node  
NAME        STATUS   ROLES   AGE   VERSION  
10.0.10.2   Ready    node    23d   v1.14.8  
10.0.10.3   Ready    node    23d   v1.14.8  
10.0.10.4   Ready    node    23d   v1.14.8  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;조회 된 내용을 보면 노드의 이름과 상태 운영 중인 시간과 버젼 정보를 볼 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;web-server-container-실행&quot;&gt;Web Server Container 실행&lt;/h1&gt;
&lt;p&gt;이제 간단하게 Nginx 서버를 각 노드에 배치 하고 Public IP 를 부여 해 보도록 하자.&lt;br /&gt;
우선 Nginx 를 이용하여 웹서버를 배포하는 작업을 하도록 하겠다. 이를 위해 다음과 같이 nginx-web-deployment.yaml 파일을 작성 한다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web-deployment&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web&lt;/span&gt;

 &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:latest&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cluster 에 container 구동을 위해서는 다음과 같이 실행 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-deployment.yaml  
deployment.apps/nginx-web-deployment created  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음은 Public IP 를 가지고 서비스를 하기 위한 service 를 설정 해 주어야 한다. 다음 YAML 파일을 생성 하여 배포 하도록 한다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;webserver&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cluster 에 Service 다음과 같이 배포 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-service.yaml  
service/webserver created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Kubernetes container 의 상태는 다음과 같은 명령어로 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all  
NAME                                        READY   STATUS    RESTARTS   AGE  
pod/nginx-web-deployment-77757cd987-4vhq2   1/1     Running   0          5m11s    
pod/nginx-web-deployment-77757cd987-lqkp5   1/1     Running   0          5m11s  
pod/nginx-web-deployment-77757cd987-plr56   1/1     Running   0          5m11s  

NAME                 TYPE           CLUSTER-IP    EXTERNAL-IP      PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        AGE  
service/kubernetes   ClusterIP      10.96.0.1     &amp;lt;none&amp;gt;           443/TCP        23d  
service/webserver    LoadBalancer   10.96.30.33   129.213.175.32   80:32244/TCP   53s  

NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE  
deployment.apps/nginx-web-deployment   3/3     3            3           5m11s  

NAME                                              DESIRED   CURRENT   READY   AGE  
replicaset.apps/nginx-web-deployment-77757cd987   3         3         3       5m11s  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;External-IP 로 Public IP 가 부여 된 것을 볼 수 있다 해당 IP 로 접근 해 보도록 한다.
&lt;img src=&quot;/image/kubernetes/kubernetes-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;YAMl 파일은 다음 github 에서 받을 수 있다. &lt;a href=&quot;https://github.com/xers989/oke/tree/master/nginx-web&quot;&gt;https://github.com/xers989/oke/tree/master/nginx-web&lt;/a&gt;&lt;br /&gt;
배포한 Container 의 삭제는 다음과 같이 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-service.yaml
service &lt;span class=&quot;s2&quot;&gt;&quot;webserver&quot;&lt;/span&gt; deleted
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-deployment.yaml 
deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;nginx-web-deployment&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OKE 는 Kubernetes Container 구동을 위한 표준을 준수하고 있어 Kubernetes 를 공부 할 때 유용하게 활용 할 수 있으며 Kubernetes 에서 cloud vendor 로 서비스 배포 연계 또한 지원하여 Load Balancer 와 같은 Cloud Vendor 가 제공하는 서비스를 간편하게 설정 구동 할 수 있는 장점이 있다. 이후에 Oracle Cloud 를 활용한 Kubernetes Container 구동을 살펴 보겠다.&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Oracle Kubernetes OKE 는 Oracle Kubernetes Engine 으로 Managed Kubernetes 로 별도 설치할 필요 없이 편리하게 사용 할 수 있다는 장점을 제공 한다. 특히 Kubernetes Master 가 3개로 설치 되어 장애 등에 대비 할 수 있는 것이 장점이다. 글을 쓰지 시점에는 지원 되는 버전이 1.14.8, 1.13.5, 1.12.7 이 제공 되고 있다. 별도로 Kubernetes 를 설치 하기 번거롭다면 OKE 를 이용하여 충분히 Kubernetes 를 공부해 볼 수 있다. OKE 를 구성 하려면 Oracle Cloud 에 로그인 하여 Developer Service 에서 cluster 를 선택 하면 된다.</summary></entry><entry><title type="html">dns-service</title><link href="http://localhost:4000/edge/dns/dns-service2/" rel="alternate" type="text/html" title="dns-service" /><published>2020-01-10T14:42:00+09:00</published><updated>2020-01-10T14:42:00+09:00</updated><id>http://localhost:4000/edge/dns/dns-service2</id><content type="html" xml:base="http://localhost:4000/edge/dns/dns-service2/">&lt;h1 id=&quot;traffic-management&quot;&gt;Traffic Management&lt;/h1&gt;
&lt;p&gt;이전 DNS 관련글에서 DNS zone management 를 이용하는 도메인 관리를 소개하였다. 이를 활용 하여 지역별로 웹서버를 설정 하고 사용자 지역에 따라 가까운 서버에서 응답하도록 구성 하여 보겠다. 하나의 도메인에 여러개의 웹서버를 구성하여 트래픽이 분산 처리 되도록 구성 하여 장애에 대한 대처나 성능을 최대화 하기 위한 방안으로 활용이 가능하며 단지 DNS 을 활용한 것으로 빠르게 적용할 수 있다는 것이 장점이다.
그림을 다시 그려 보면 북미와 유럽, 아시아에 각각 웹서버를 배치하고 Edge DNS가 사용자의 위치에 따라 가까운 웹서버로 전달 되도록 경로를 조정 해 주는 것이다. 즉 사용자가 app.service.com 의 주소를 Edge DNS 에 질의하면 가장 가까운 웹서버의 주소를 반환하여 빠르게 응답을 받을 수 있게 된다. 이를 활용하여 글로벌한 Active-Active 서비스 구성을 할 수 있다. 2개 이상의 데이터 센터를 구성 하고 동일한 서비스를 Active-Active 하게 활용하기 위해 글로벌 로드 밸란서를 활용하여 트래픽을 분산하였는데 Edge DNS 를 활용한 다면 쉽게 대체 할 수 있다. 또한 트래픽이 분산되도록 결정을 담당하는 Traffic Management 가 Edge에서 서비스되어 글로벌하게 배포되어 있어 글로벌한 서비스에 활용한 다면 큰 장점을 얻을 수 있다
&lt;img src=&quot;/image/dns-service2/dns-service-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;web-server&quot;&gt;Web Server&lt;/h1&gt;
&lt;p&gt;오라클 클라우드 서비스를 활용하여 서울, 런던, 미국에 웹서버를 구성 하고 사용자별로 어디로 서비스가 전달 되는지 보도록 하겠다. 각 지역별로 웹서버를 구성 하기 위해 오라클 클라우드의 데이터 센터 리전을 확장 하도록 한다. 오라클 클라드에 로그인 하여 상단에 검색 버튼 옆에 데이터 센터를 클릭 하면 리전관리 (Manage Regions) 를 볼 수 있다. 기본 데이터 센터가 Ashburn 으로 하여 London 과 Seoul 을 추가 하도록 한다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 미국 지역에 웹서버를 구성 하도록 한다. 지역을 US East (Ashburn) 으로 선택 한다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-3.png&quot; alt=&quot;&quot; /&gt;
Instance 를 생성 하기 전에 우선 Identity &amp;gt; Compartment 에서 테스트를 위한 Compartment 를 생성 하여 준다.
테스트용 VCN 를 구성해야 한다. 테스트 복적임으로 Quickstart 를 이용하여 바로 생성 하여 준다.
Network &amp;gt; Virtual Cloud Networks &amp;gt; Networking Quickstart &amp;gt; VCN with Internet Connectivity 를 선택하여 네트워크를 구성 한다.&lt;br /&gt;
VCN 은 테스트를 위한 것임으로 테스트 목적에 맞게 구성하고 Compartment 를 꼭 선택 하여 준다. VCN CIDR Block 은 테스트 용도 임으로 10.0.0.0/16 으로 하고 Public Subnet 의 CIDR 은 10.0.0.0/24 하고 Private Subnet 의 CIDR dms 10.0.1.0/24 로 하여 생성 하여 준다. 생성 되는 네트워크는 기본적인 구성으로 Public subnet 와 Private subnet 으로 구성 되며 Public subnet 에 생성 되는 Instance 는 Public IP 를 가지게 된다.&lt;/p&gt;

&lt;p&gt;Compute &amp;gt; Instances 에서 Create Instance 를 한다. 간단히 Docker 를 활용하여 웹서버를 구성할 것임으로 instance Shape 은 VM.Standard.E2.1 정도로 하면 된다.
Show Shape, Network and Storage Options 를 클릭 하여 상세 설정 부분에서 Shape 를 선택 하고 compartment 와 VCN / Subnet 을 선택 한다. Public IP 를 부여 받아야 함으로 Public Subnet 을 선택 한다. 또한 Assign a public IP address 를 선택 하여 준다.
SSH 접근을 위해 비대칭키의 Public key 를 등록 하여 준다.
&lt;img src=&quot;/image/dns-service2/dns-service-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성이 완료 되면 부여된 Public IP 를 이용하여 Instance 에 ssh 접근을 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum update
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-engine
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker opc
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;reboot
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start docker
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;80/tcp
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; ‘This is my Web-Server running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;Ashburn’ &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps 
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
6beeca27476d        httpd               &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;   2 minutes ago       Up About a minute   0.0.0.0:80-&amp;gt;80/tcp   http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;80 으로 서비스를 허용해 주기 위해 Public subnet 의 security list 에 80 을 추가 하여 준다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-5.png&quot; alt=&quot;&quot; /&gt;
브라우저로 접근이 가능한지 테스트 하여 보자&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동일한 작업을 직역을 변경 하여 진행 하여 준다. 
지역 : UK South (London)
VCN : EU_VCN
Docker image 를 생성할 때 웹서버를 구분 하여 보기 위해 index.html 파일을 생성 할 때 다음과 같이 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; ‘This is my Web-Server running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;London’ &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;지역 : South Korea Central (Seoul)
VCN : KR_VCN
Docker image 를 생성할 때 웹서버를 구분 하여 보기 위해 index.html 파일을 생성 할 때 다음과 같이 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; ‘This is my Web-Server running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;Seoul’ &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;웹으로 접근이 가능한 지 확인 하여 보자&lt;/p&gt;

&lt;p&gt;London 에 설치한 웹서버&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-7.png&quot; alt=&quot;&quot; /&gt;
Seoul 에 설치한 웹서버&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;traffic-manangement&quot;&gt;Traffic Manangement&lt;/h1&gt;
&lt;p&gt;이제 도메인을 DNS 에 등록 하고 설치 한 웹서버의 IP 를 DNS Record 에 등록 하여 주면 도메인 등록이 완료될 것이다. 그러나 3대의 웹서버를 하나의 도메인으로 연결하고 사용자의 위치 정보에 따라 트래픽이 분배 되도록 조정 하겠다.
우선 이전 포스트에서 처럼 DNS Zone management 에 도메인이 등록이 사전에 필요하다. 등록이 완료 되었으면 Cloud 에 로그인 하여 Network &amp;gt; Traffic management 에서 새로운 Traffic Management Steering Policy 를 생성 한다.
Traffic Management Steering Policy 은 다음 순서로 등록 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Policy Type : 트래픽을 분배 하기 위한 규칙으로 5 가지의 타입이 있으며 이중 하나를 선택 할 수 있다. 
2. Answer Pool : 트래픽 규칙을 생성 할 때 선택 가능 응답으로 웹트래픽이 전달 될 곳을 의미 한다.
3. Steering Rules : Policy Type 에 따라 구성 되며 Type 에 따른 규칙을 실제로 정의 한다.
4. Attach Health Check : 대상 시스템의 작동 유무를 판단 하기 위한 것으로 기존 등록된 것을 선택하거나 새로생성, 없음을 선택 할 수 있다.
5. Attached Domain : Policy 를 적용할 Domain 을 선택
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;policy-type&quot;&gt;Policy Type&lt;/h3&gt;
&lt;p&gt;Geolocation 을 선택 하고 Policy Name 은 WebServerGeolocationSteering 으로 하고 Policy TTL 은 60 초, Maximum Answer count 는 1 로 등록 하여 준다.
&lt;img src=&quot;/image/dns-service2/dns-service-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;answer-pool&quot;&gt;Answer Pool&lt;/h3&gt;
&lt;p&gt;Steering Rule 을 등록 할 때 선택 가능한 응답을 등록 하는 곳으로 등록 된 3개 서버 (Ashburn, London, Seoul) 에서 서비스를 할 것임으로 3개를 Answer Pool 로 등록 하여 준다. 
Pool Name 은 알아보기 쉽게 Ashburn 으로 하고 Answers Name 은 us, type 은 A RDATA 는 Ashburn 웹서버의 IP 를 작성 하여 준다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool&lt;/td&gt;
      &lt;td&gt;Answer Pool Name&lt;/td&gt;
      &lt;td&gt;Answers Name&lt;/td&gt;
      &lt;td&gt;Type&lt;/td&gt;
      &lt;td&gt;RData&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool 1&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
      &lt;td&gt;us&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;IP_ADDRESS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool 2&lt;/td&gt;
      &lt;td&gt;EU&lt;/td&gt;
      &lt;td&gt;eu&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;IP_ADDRESS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool 3&lt;/td&gt;
      &lt;td&gt;ASIA&lt;/td&gt;
      &lt;td&gt;asia&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;IP_ADDRESS&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;geolocation-steering-rules&quot;&gt;Geolocation Steering Rules&lt;/h3&gt;
&lt;p&gt;위치에 따른 응답을 선택 하는 것으로 복수개의 규칙을 등록 할 수 있으며 순서대로 실행 된다.
Geolocation 은 대륙 및 나라가 선택 가능 하며 Add Global Catch-All 이 기본으로 선택되게 된다.
시나리오는 유럽과 아프리카는 London 웹서버에서 응답을 주고 백업으로 Ashburn 에서 해주도록 구성 하며 아메리카 대륙은 Ashburn 에서 응답을 주고 London 이 백업 하며 아시아와 호주 지역은 Seoul 에서 응답하고 Ashburn 이 백업 하도록 한다. 그 외에 지역은 Ashburn, Seoul 에서 응답을 주는 것으로 구성 하도록 한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Rule&lt;/th&gt;
      &lt;th&gt;Geolocation&lt;/th&gt;
      &lt;th&gt;Pool Priority 1&lt;/th&gt;
      &lt;th&gt;Pool Priority 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Rule1&lt;/td&gt;
      &lt;td&gt;North America, South America&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
      &lt;td&gt;EU&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rule2&lt;/td&gt;
      &lt;td&gt;Asia, Oceania&lt;/td&gt;
      &lt;td&gt;ASIA&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rule3&lt;/td&gt;
      &lt;td&gt;Europe, Africa&lt;/td&gt;
      &lt;td&gt;EU&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Catchall&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
      &lt;td&gt;ASIA&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;attach-health-check--attach-domain&quot;&gt;Attach Health Check &amp;amp; Attach domain&lt;/h3&gt;
&lt;p&gt;웹서버를 구성 할 때 헬스체크를 위한 서비스를 등록 하였다면 Health Check 를 등록 하여 응답 불가능 한 상태일 때 다음 서버가 응답을 주도록 구성 할 수 있다. 이번 포스팅에서는 헬스체크를 위한 서비스를 등록 하지 않았음으로 없음을 선택 한다.
Attach Domain 은 이전 포스트에서 등록 한 DNS zone 을 선택 하여 Subdomain 에 app 를 입력 해 준다. 등록이 완료 된다면 app.&lt;em&gt;.&lt;/em&gt; 으로 서비스 될 것 이다.&lt;/p&gt;

&lt;h1 id=&quot;geolocation-test&quot;&gt;Geolocation Test&lt;/h1&gt;
&lt;p&gt;준비가 완료 되었음으로 브라우저의 Geolocation 을 변경 하기 위한 Proxy 를 설치 해준다. firefox 에는 Hoxx 라는 무료 plugin 이 있으니 이를 이용하면 된다. 테스트를 할 때 꼭 브라우저 캐시를 지우고 들어가도록 한다. 우선 국내에서 등록한 도메인으로 접근 하는 경우 웹서버는 Seoul 에서 응답해야 할 것이다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-10.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
이제 위치를 바꾸기 위해 브라우저에 설치된 Hoxx 를 클릭 하고 독일을 선택 한다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-11.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
브라우저의 캐시를 삭제하고 다시 접근 하면 London 에서 응답을 줄 것 이다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-12.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
다시 Hoxx 연결을 끊고 미국을 선택 한 후 브라우저 캐시를 삭제하고 접근하면 Ashburn 웹서버에서 응답을 줄 것이다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자 브라우저의 위치에 따라 가까운 웹서버에서 응답을 주도록 구성을 하였으며 장애 발생시 응답을 줄 수 있는 곳까지 등록 하였음으로 안정적으로 서비스 가능한 구성이 편리 하게 되었다. 지역별 위치한 웹서버에 대한 동기화는 다루지 않았지만 동기화가 된다면 트래픽을 효과적으로 분산 할 수 있음으로 매우 효율적일 것이며 지역별 서버에 해당 지역 언어로 서비스 하로독 구성하여 보다 편리한 서비스를 구성 할 수 있을 것이다.&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Traffic Management 이전 DNS 관련글에서 DNS zone management 를 이용하는 도메인 관리를 소개하였다. 이를 활용 하여 지역별로 웹서버를 설정 하고 사용자 지역에 따라 가까운 서버에서 응답하도록 구성 하여 보겠다. 하나의 도메인에 여러개의 웹서버를 구성하여 트래픽이 분산 처리 되도록 구성 하여 장애에 대한 대처나 성능을 최대화 하기 위한 방안으로 활용이 가능하며 단지 DNS 을 활용한 것으로 빠르게 적용할 수 있다는 것이 장점이다. 그림을 다시 그려 보면 북미와 유럽, 아시아에 각각 웹서버를 배치하고 Edge DNS가 사용자의 위치에 따라 가까운 웹서버로 전달 되도록 경로를 조정 해 주는 것이다. 즉 사용자가 app.service.com 의 주소를 Edge DNS 에 질의하면 가장 가까운 웹서버의 주소를 반환하여 빠르게 응답을 받을 수 있게 된다. 이를 활용하여 글로벌한 Active-Active 서비스 구성을 할 수 있다. 2개 이상의 데이터 센터를 구성 하고 동일한 서비스를 Active-Active 하게 활용하기 위해 글로벌 로드 밸란서를 활용하여 트래픽을 분산하였는데 Edge DNS 를 활용한 다면 쉽게 대체 할 수 있다. 또한 트래픽이 분산되도록 결정을 담당하는 Traffic Management 가 Edge에서 서비스되어 글로벌하게 배포되어 있어 글로벌한 서비스에 활용한 다면 큰 장점을 얻을 수 있다</summary></entry><entry><title type="html">dns-service</title><link href="http://localhost:4000/edge/dns/dns-service/" rel="alternate" type="text/html" title="dns-service" /><published>2020-01-02T15:02:00+09:00</published><updated>2020-01-02T15:02:00+09:00</updated><id>http://localhost:4000/edge/dns/dns-service</id><content type="html" xml:base="http://localhost:4000/edge/dns/dns-service/">&lt;h1 id=&quot;edge-서비스&quot;&gt;Edge 서비스&lt;/h1&gt;
&lt;p&gt;오라클은 2016년 11월 DYN 이란 업체를 인수 하면서 Edge 서비스를 시작 하였다.
현재는 Oracle Cloud 서비스에 통합 되어 Cloud Console 에서 사용 가능하다.&lt;/p&gt;

&lt;p&gt;Edge 서비스는 서울을 포함하여 글로벌 하게 분포 되어 있으며 사용자의 네트웍에서 가장 가까운 Edge 서비스를 통해서 Web Application 에 접근 하는 구조 이다. 이러한 구조로 글로벌 하게 일정 수준의 성능을 보여주는 Web Application 을 만들 수 있으며 장애 등에 빠르게 대응이 가능하게 된다.&lt;/p&gt;

&lt;p&gt;아래 그림에 OCI DNS 는 Oracle 이 제공 하는 Edge 서비스로 사용자가 app.service.com 에 접근 하게 되면 Recursive Server 는 OCI DNS 에 DNS 질의를 하고 OCI DNS 는 Origin Server 즉 app.service.com 의 주소를 반환 하여 사용자가 app.service.com 에 접근 할 수 있게 한다.
이때 질의를 처리하는 OCI DNS 는 사용자와 가장 가까운 곳에 있는 곳에서 응답을 주며 사용자 위치나 app.service.com 의 상태에 따라 주소를 달리 하여 일정 수준의 성능을 보여 주도록 할 수 있다.
&lt;img src=&quot;/image/dns-service/dns-service-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림을 다시 그려 보면 북미와 유럽, 아시아에 각각 Origin 서버를 배치하고 해당 지역의 Edge 에서 app.service.com 를 서비스 한다면 각 지역의 Edge 는 가장 가까운 곳의 Origin 서버에서 서비스가 진행 되도록 주소를 반환 할 수 있다. 각 app.service.com 간의 동기화는 다른 문제이지만 이를 통해 글로벌 하게 Web Application 을 각 지역에 배치 하고 해당 지역 사용자는 가까운 Web Application 을 사용하도록 하여 성능을 확보 할 수 있으며 Asia 혹은 EU 의 서버에 장애가 난 경우 서비스가 가능한 NA 로 서비스가 되도록 경로를 조정 할 수 있다. 보통 DNS 를 이용한 조정이 60 분 가량이 소요 되지만 OCI DNS 는 30 초 가량으로 빠르게 배포 될 수 있으며 REST API 를 제공 하여 서비스 이상을 감지하고 자동으로 DNS 를 조정 할 수 있는 구조를 만들수 있다.
&lt;img src=&quot;/image/dns-service/dns-service-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;oracle-dns&quot;&gt;Oracle DNS&lt;/h1&gt;
&lt;p&gt;실습을 위해서는 우선 도메인이 필요 하며 도메인 관리 업체에 Domain Name Server 를 OCI 에서 진행 할 것이라는 것을 알려 주어야 한다.
OCI 콜솔에 로그인 한 후 Neworking 메뉴에서 DNS Zone Management 를 선택 한다.
DNS Zone 은 도메인 이름을 관리 해주는 솔루션으로 사용할 도메인을 등록 하여 OCI DNS 에서 해당 주소를 서비스 하도록 설정 하여야 한다. 이를 위해 Creae Zone 을 한다.
Zone 생성은 매우 간단하게 Zone Type 을 Primary 로 하고 Zone Name 에 사용할 도메일 이름을 작성 해 준다. (참고로 DNS Zone 은 Oracle Compartment 에 의해 관리 됨으로 생성 하기 전에 꼭 Compartment 를 선택 하여야 한다)
&lt;img src=&quot;/image/dns-service/dns-service-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성이 완료 되면 OCI DNS 의 네임서버 정보를 볼 수 있게 된다. 이제 DNS 제공자에게 이 네임서버를 이용해서 서비스 할 것이라는 것을 알리는 과정이 필요하다
&lt;img src=&quot;/image/dns-service/dns-service-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Godaddy 의 경우 도메인 관리에서 DNS Management 에서 Nameservers 를 변경 하는 것이 가능하다. NameServer 를 Use my own nameservers 로 선택 하고 OCI DNS 에서 제공 하는 Name Server 를 입력 하여 준다
&lt;img src=&quot;/image/dns-service/dns-service-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;web-application&quot;&gt;Web Application&lt;/h1&gt;
&lt;p&gt;도메인 등록이 완료 되었으니 간단히 웹서버를 만들어서 서비스를 하여 DNS 가 정상 동작하는 지 볼것이다. OCI 에 Docker 를 이용하여 Apache 서버를 기동 시킬 것이다. 구매한 도메인이 iamhub.site 임으로 edge.iamhub.site 로 만들 것이다.
우선 클라우드에 Public IP 는 VM 을 구성하고 docker 를 설치 하여 보자.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# yum install docker-engine  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# usermod -aG docker opc  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# systemctl start docker&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;포트는 80 으로 할 것임으로 방화벽과 클라우드 Security List 에 80 이 허용 되도록 변경 하여 준다 (Linux7 기준으로 아래 두개 중 하나를 해주면 된다)&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# firewall-cmd --add-service=http  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# firewall-cmd --add-port=80/tcp  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 docker 를 이용하여 Apache Web server 를 구동 시켜 보자.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'This is my Web-Server running on docker'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 Docker 가 구동이 되었다면 다음 처럼 Wep Page 가 보여 질 것이다.
&lt;img src=&quot;/image/dns-service/dns-service-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 DNS Zone management 에서 DNS 를 둥록 하여 볼 것이다. iamhub.site 라는 Domain 을 소유 하고 있어 app.iamhub.site 로 등록 하여 볼 것이다.
Cloud 에 로그인 하여 Networking &amp;gt; DNS Zone Management 에서 등록 한 zone 을 선택 한 후 Records 를 선택 하면 DNS 를 추가 할 수 있다. app.iamhub.site 라는 A 타입을 추가 하여 주고 대상 시스템의 IP 를 등록 해 주면 된다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장 후에 내용을 Edge 로 배포 하기 위해 publish changes 를 해 주어야 한다. 배포는 몇 초 이내로 완료 된다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배포가 완료 되면 도메인 이름으로 서버 접근이 가능 하다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 포스트에서는 웹서버를 서로 다른 지역에 두고 가까운 곳에서 서비스가 되도록 구성하여 보겠다&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Edge 서비스 오라클은 2016년 11월 DYN 이란 업체를 인수 하면서 Edge 서비스를 시작 하였다. 현재는 Oracle Cloud 서비스에 통합 되어 Cloud Console 에서 사용 가능하다.</summary></entry></feed>