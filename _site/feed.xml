<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-09T13:26:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jake Kim</title><author><name>Jake Kim</name></author><entry><title type="html">WAF 등록</title><link href="http://localhost:4000/edge/waf/WAF-register/" rel="alternate" type="text/html" title="WAF 등록" /><published>2020-03-08T19:46:00+09:00</published><updated>2020-03-08T19:46:00+09:00</updated><id>http://localhost:4000/edge/waf/WAF-register</id><content type="html" xml:base="http://localhost:4000/edge/waf/WAF-register/">&lt;h1 id=&quot;web-application-firewall&quot;&gt;Web Application firewall&lt;/h1&gt;
&lt;p&gt;웹애플리케이션 방화벽(이하 WAF)은 기존 방화벽이 네트워크의 레이어 3,4 에서 동작하는 방화벽을 개선 한 것이다. 이름에서 예측 할 수 있듯이 레이어 7 방화벽으로 웹 트래픽 내부에 데이터까지 스캐닝 하여 악성 코드나 인젝션 공격 등을 사전에 방어 하는 서비스이다. 증가되고 있는 DDoS 공격 등을 감지하고 방어하여 도입이 늘어나는 추세라고 볼 수 있다.
WAF는 크게 두 가지 형태로 구분해 볼 수 있는데 데이터 센터내에 설치 구현하는 방법과 클라우드에 설치 하는 방법으로 나눌 수가 있다.
데이터 센터내에 설치 하는 것은 인터넷을 거쳐 유입되는 트래픽을 웹서버로 전달 하기 전에 검사하는 것으로 검사 장비가 데이터 센터내에 설치 되는 것이다. 이 경우 DDoS 공격을 받게 되면 WAF 자체도 부하를 받게 되어 효과적인 방어가 어려울 수 있으며 늘어나는 공격방법에 대한 업데이트를 주기적으로 해주어야 하는 단점이 있다. 클라우드에 설치되는 WAF서비스를 클라우드에 배포 하고 처리 하는 것으로 클라우드 특성을 활용하여 DDoS 공격 등에 자원을 동적으로 증가 시켜 대응 하여 공격을 방어 한다. 또한 서비스 형태의 WAF는 증가되는 공격 방법을 주기적으로 업데이트 하여 주어 관리 측면에 장점이 있다.
오라클 WAF는 클라우드 기반의 방화벽 서비스로 사용한 만큼만 지불 하기 때문에 도입비용이 낮고 적용이 매우 간단하다는 장점이 있다. &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림과 같이 WAF 는 데이터 센터 혹은 애플리케이션이 설치된 네트워크 외부에 배치 되어 있어 애플리케이션에 영향을 영향을 주지 않는다. 동작은 Proxy서버 처럼 모든 트래픽을 앞단에서 처리 하는 역할을 한다. WAF를 거치도록 처리하는 것은 DNS를 이용하여 간단하게 처리 될 수 있으며 애플리케이션에 전혀 수정이 없이 빠르게 처리 될 수 있다. 방법은 DNS 제공자, 예를 들어 goDaddy,가 제공하는 도메인 주소를 WAF주소로 설정하고 WAF서비스가 이를 받아 처리하고 정상 트랙픽만을 웹애플리케이션(통산 Origin 이라고 한다)으로 전달 한다. 오라클 WAF는 Edge에서 제공하는 서비스로 오라클이 제공하는 모든 Edge에 설정한 WAF정보가 배포된다. 만약 유럽의 사용자가 웹애플리케이션을 접근 하는 경우 유럽에 설치된 Edge의 WAF에 트래픽이 전달 되어 처리 된다. 한국 사용자의 경우 한국에 설치된 Edge의 WAF에 트래픽이 전달된다.  &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 처럼 글로벌 하게 분포된 Edge가 사용자의 트래픽을 받고 그 중 정상 트래픽만을 웹애플리케이션(origin)으로 전달한다. DDoS를 포함한 외부 공격을 앞단에서 방어 하여 웹애플리케이션에 영향을 주지 않는 구조이다.&lt;/p&gt;

&lt;h1 id=&quot;waf-설정&quot;&gt;WAF 설정&lt;/h1&gt;
&lt;p&gt;WAF 설정을 위해서는 웹애플리케이션의 도메인명이 등록 되어 있어야 한다. DNS를 이용하여 WAF를 경유 하도록 하는 구조임으로 테스트등을 하기 위해서는 도메인을 보유 하고 있어야 한다. korwaf.site라는 도메인을 보유하고 있음으로 waf.korwaf.site 도메인을 생성하고 웹어플리에션을 생성하는 방법을 소개 하도록 하겠다. &lt;br /&gt;
전체 구조는 다음과 같다. &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-04.png&quot; alt=&quot;&quot; /&gt;
Origin에 Web Application을 구성 하고 WAF에 Origin을 등록 하여 주면 고유한 주소가 생성이 되며 이를 DNS에 등록 하여 주면 설정이 완료 된다. 사용자가 도메인 (waf.korwaf.site)을 접근 하려 할때 DNS는 WAF의 주소를 반환하게 되며 WAF는 사용자 트래픽을 설정된 Origin으로 전달하는 구조이다.&lt;/p&gt;

&lt;h4 id=&quot;web-application-설치&quot;&gt;Web application 설치&lt;/h4&gt;
&lt;p&gt;애플리케이션의 취약점을 테스트 하기 위한 웹애플리케이션을 설치하도록 한다. 취약점을 테스트하기 위한 Docker image DVWA를 사용하도록 한다.   (https://hub.docker.com/r/vulnerables/web-dvwa)  &lt;br /&gt;
공용 IP를 가지고 있는 인스턴스를 생성 한 후에 Docker engine을 설치 한다. 로컬 환경에 머신과 공용 IP가 있다면 로컬에 구성 하여도 상관없으나 빠르게 환경을 구성하기 위해서는 클라우드 환경을 추천 한다. Linux 환경을 기준으로 Docker engine 설치와 docker image 를 구동 하는 것 명령어 이다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@wafapplication]# yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-engine &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;  

&lt;span class=&quot;o&quot;&gt;====================================================================================================================================================&lt;/span&gt;
 Package                             Arch                     Version                                            Repository                    Size
&lt;span class=&quot;o&quot;&gt;====================================================================================================================================================&lt;/span&gt;
Installing:
 docker-engine                       x86_64                   19.03.1.ol-1.0.0.el7                               ol7_addons                    24 M
Installing &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;dependencies:
 container-selinux                   noarch                   2:2.77-5.el7                                       ol7_addons                    37 k
 containerd                          x86_64                   1.2.0-1.0.5.el7                                    ol7_addons                    21 M
 criu                                x86_64                   3.12-2.el7                                         ol7_latest                   452 k
 docker-cli                          x86_64                   19.03.1.ol-1.0.0.el7                               ol7_addons                    40 M
 libnet                              x86_64                   1.1.6-7.el7                                        ol7_latest                    57 k
 protobuf-c                          x86_64                   1.0.2-3.el7                                        ol7_latest                    27 k
 runc                                x86_64                   1.0.0-19.rc5.git4bb1fe4.0.4.el7                    ol7_addons                   1.9 M

Transaction Summary
&lt;span class=&quot;o&quot;&gt;====================================================================================================================================================&lt;/span&gt;
Install  1 Package &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+7 Dependent packages&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

Total download size: 88 M
Installed size: 370 M
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@wafapplication]# usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker opc
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@wafapplication]# reboot  
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;opc@wafapplication]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start docker
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;opc@wafapplication]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;80/tcp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;opc@wafapplication]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;opc@wafapplication]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; waf &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 vulnerables/web-dvwa
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;opc@wafapplication]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
CONTAINER ID        IMAGE                  COMMAND             CREATED             STATUS              PORTS                NAMES
9414f813e5e2        vulnerables/web-dvwa   &lt;span class=&quot;s2&quot;&gt;&quot;/main.sh&quot;&lt;/span&gt;          3 minutes ago        Up 3 minutes          0.0.0.0:80-&amp;gt;80/tcp   waf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;애플리케이션은 80 포트로 오픈됨으로 ACL 에 80포트가 접근 가능하도록 허용해준 후에 공용 IP로 접속 한다.
최초로 접속 하면 Database를 생성하라는 메시지를 볼 수 있다. MySQL로 생성 되며 이후 자동으로 로그인 페이지로 접속하게 된다. 접근 ID는 admin이다.&lt;/p&gt;

&lt;h4 id=&quot;waf-policy-생성&quot;&gt;WAF Policy 생성&lt;/h4&gt;
&lt;p&gt;오라클 클라우드의 OCI 콘솔에 로그인 한 후 Security탭에 WAF Policies를 선택 한다. 등록한 WAF Policy가 Compartment에 소속됨으로 적절한 Compartment를 선택하여 준다.
Create WAF Policy를 클릭 하면 다음과 같은 화면을 볼 수 있다.  &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Policy Name을 입력 하여 주고 Domains의 Primary Domain에 도메인(waf.korwaf.site)를 등록 하여 준다.
WAF Origin에는 Origin을 구분 하기 위한 이름을 입력 하고 URI 부분에 Origin의 공용 IP를 입력 하여 준다. &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장 후 몇 분간 Edge에 등록한 WAF Policy를 배포 하기 시작 한다. 전체 Edge에 배포되기 때문에 약간의 시간이 소요 된다. 등록이 완료 되면 다음과 같이 세부 정보 및 메시지를 볼 수 있다. Policy 정보중 CNAME Target을 복사하여 준다. &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dns-변경&quot;&gt;DNS 변경&lt;/h4&gt;
&lt;p&gt;Domain인 제공자가 제공하는 도메인 관리 페이지에서 도메인을 수정하여 주어야 한다. Godaddy에서 관리하는 도메인임으로 godaddy에 로그인 하여 DNS 관리를 선택 한다. 도메인의 레코드 관리에 들어가서 레코드를 추가 하여 준다. 유형은 CNAME을 선택 하고 호스트는 waf를 입력하여 준다.(waf.korwaf.site 라는 도메인을 서비스 하기 위한 것) 지시 방향에 WAF Policy 정보의 CNAME Target을 복사하여 준다. TTL 은 1시간 혹은 1/2 시간을 선택 하여 준다. (해당 시간 안에 변경 사항이 적용 된다)  &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설정이 완료 되면 nslookup 으로 WAF 를 거쳐 가는지 점검하여 본다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Jakes-MacBook-Pro:~ jakekim&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nslookup waf.korwaf.site
Server:		168.126.63.1
Address:	168.126.63.1#53

Non-authoritative answer:
waf.korwaf.site	canonical name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; waf-korwaf-site.o.waas.oci.oraclecloud.net.
waf-korwaf-site.o.waas.oci.oraclecloud.net	canonical name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; tm.inregion.waas.oci.oraclecloud.net.
tm.inregion.waas.oci.oraclecloud.net	canonical name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; apac-seoul.inregion.waas.oci.oraclecloud.net.
Name:	apac-seoul.inregion.waas.oci.oraclecloud.net
Address: 192.29.19.39
Name:	apac-seoul.inregion.waas.oci.oraclecloud.net
Address: 192.29.18.3
Name:	apac-seoul.inregion.waas.oci.oraclecloud.net
Address: 192.29.19.178
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어 결과에서 볼 수 있 듯이 lookup 결과 apac-seoul.inregion.waas.oci.oraclecloud.net 으로 트래픽이 가는 것을 볼 수 있다. nslookup 하는 장소에 따라 서울 혹은 일본 등으로 경로가 설정 될 수 있다.
등록이 완료 되었음으로 도메인 주소로 들어가면 정상적으로 웹애플리케이션이 오픈을 확인 하여 준다.  &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;기본-waf-설정&quot;&gt;기본 WAF 설정&lt;/h4&gt;
&lt;p&gt;OCI의 WAF Policies에 들어가면 등록되어진 WAF Policy를 선택 할 수 있다. 초기는 아무런 설정이 없기 때문에 모든 트래픽이 그대로 Origin으로 전달 되는 형태 이다. 메뉴 옵션을 보면 Origin Management 에서 입력한 Origin에 대한 정보를 볼 수 있으며 IP가 변경 되거나 할 경우 이를 수정하여 주면 된다.
Settings 에서는 도메인을 http 혹은 https 로 할지를 선택 할 수 있다. WAF는 애플리케이션 레벨의 방화벽임으로 암호화 되어 전달 되는 데이터를 복호화 할 필요가 있기 때문에 https 로 하는 경우 인증서를 등록 해 주어야 한다. 현재 Web application 이 http 만 서비스 하기 때문에 수정 할 필요는 없다. (https를 설정할 경우 https enable 을 선택) &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 WAF 의 핵심인 Protection Rules 이다. 외부 공격을 방어하기 위한 패턴 규칙이 약 450여개가 등록 되어 있으며 선별하여 적용이 가능하다. 각 패턴별로 대응하기 위한 액션을 선택 할 수 있다. Off 는 패턴을 보지 않으며 Detect 의 경우 로그만을 기록 하고 트래픽이 전달 되며 block을 선택 하면 해당 패턴의 트래픽은 차단 된다.  &lt;br /&gt;
&lt;img src=&quot;/image/waf-register/waf-11.png&quot; alt=&quot;&quot; /&gt;
기본값은 전체가 Off로 설정 되어 있다. 
Recommendation 탭을 보면 WAF 가 웹 애플리케이션 및 기존 트래픽을 분석 하여 Protection Rule 을 추천 하여 준다. (등록 후 얼마간의 시간이 지나야 추천 Rule 들이 보이게 된다)&lt;/p&gt;

&lt;p&gt;다음 POST에서는 OWASP에 대한 패턴과 WAF가 이를 탐지하는 내용을 보도록 하겠다.&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Web Application firewall 웹애플리케이션 방화벽(이하 WAF)은 기존 방화벽이 네트워크의 레이어 3,4 에서 동작하는 방화벽을 개선 한 것이다. 이름에서 예측 할 수 있듯이 레이어 7 방화벽으로 웹 트래픽 내부에 데이터까지 스캐닝 하여 악성 코드나 인젝션 공격 등을 사전에 방어 하는 서비스이다. 증가되고 있는 DDoS 공격 등을 감지하고 방어하여 도입이 늘어나는 추세라고 볼 수 있다. WAF는 크게 두 가지 형태로 구분해 볼 수 있는데 데이터 센터내에 설치 구현하는 방법과 클라우드에 설치 하는 방법으로 나눌 수가 있다. 데이터 센터내에 설치 하는 것은 인터넷을 거쳐 유입되는 트래픽을 웹서버로 전달 하기 전에 검사하는 것으로 검사 장비가 데이터 센터내에 설치 되는 것이다. 이 경우 DDoS 공격을 받게 되면 WAF 자체도 부하를 받게 되어 효과적인 방어가 어려울 수 있으며 늘어나는 공격방법에 대한 업데이트를 주기적으로 해주어야 하는 단점이 있다. 클라우드에 설치되는 WAF서비스를 클라우드에 배포 하고 처리 하는 것으로 클라우드 특성을 활용하여 DDoS 공격 등에 자원을 동적으로 증가 시켜 대응 하여 공격을 방어 한다. 또한 서비스 형태의 WAF는 증가되는 공격 방법을 주기적으로 업데이트 하여 주어 관리 측면에 장점이 있다. 오라클 WAF는 클라우드 기반의 방화벽 서비스로 사용한 만큼만 지불 하기 때문에 도입비용이 낮고 적용이 매우 간단하다는 장점이 있다.</summary></entry><entry><title type="html">Container Repository</title><link href="http://localhost:4000/oke/container/respository/OCIR-basic/" rel="alternate" type="text/html" title="Container Repository" /><published>2020-03-06T16:57:53+09:00</published><updated>2020-03-06T16:57:53+09:00</updated><id>http://localhost:4000/oke/container/respository/OCIR-basic</id><content type="html" xml:base="http://localhost:4000/oke/container/respository/OCIR-basic/">&lt;h1 id=&quot;container-repository&quot;&gt;Container Repository&lt;/h1&gt;
&lt;p&gt;Oracle Kubernetes Engine는 Docker를 기반으로 하는 서비스로 컨테이너 이미지를 보관하고 공유 하기 위한 별도 서비스가 필요하다. Oracle cloud를 사용 한 다면 무료로 Container Image Registry를 사용 할 수 있으며 접근을 위한 사용자 관리가 제공 되어 유용하게 활용 할 수 있다.
Cloud 계정이 있다면 OCI Console의 개발자 메뉴에서 OCIR (Oracle Cloud Infrastructure Registry)을 볼 수 있다. Oracle Cloud를 사용 하면 홈 리전을 선택 하여 기본 데이터 센터를 선택 하게 되는데 이때 Tenancy의 Object Storage Namespace가 생성 된다. Registry는 해당 Object Storage Namespace (이를 tenancy namespace 라고도 한다)를 이용하여 접근 한다.
우선 이미지가 저장될 Repostory 를 생성 하여 보자. &lt;br /&gt;
&lt;img src=&quot;/image/ocir/ocir-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Create Repository를 클릭 하고 이름을 지정하여 준다. 접근 정책은 외부 사용을 제한 하기 위해 Private 로 선택 한다.&lt;br /&gt;
&lt;img src=&quot;/image/ocir/ocir-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Registry의 사용자는 Cloud의 IAM에서 관리되는 사용자로 접근이 가능하다. 로그인 정보는 파일에 기록 되어 해당 PC 에서는 로그인 된 상태가 저장 되게 된다. 안전한 접근 권한 및 보안을 위한 IAM은 AuthToken을 제공 하고 있다. 즉, 패스워드를 넣지 않고 임의 생성된 Toke을 이용하여 접근 하도록 하여 패스워드의 유출을 방지 하는 것이다. AuthToken은 사용자 정보에서 생성이 가능하며 한번 생성 된 AuthToken은 이후로 다시 조회가 불가능 하다. &lt;br /&gt;
&lt;img src=&quot;/image/ocir/ocir-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;콘솔에서 다음 명령어를 이용하여 생성한 Registry에 로그인을 한다.
iad.ocir.io는 로그인 하기 위한 registry를 지정 하는 것으로 iad (Ashburn region)의 ocir (Registry)에 로그인을 하는 것을 의미 한다. 참고로 서울은 icn.ocir.io로 로그인 할 수 있다.
사용자는 “Object Namespace/사용자이름” 으로 IAM 의 사용자 정보에서 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker login iad.ocir.io
Username &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;idcollxtpgky/okeuser&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: idbkzk6hw0ua/oracleidentitycloudservice/&lt;span class=&quot;k&quot;&gt;****&lt;/span&gt;
Password: 
WARNING! Your password will be stored unencrypted &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/jakekim/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store
Login Succeeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로그인이 완료 되었음으로 이제 업로드할 Docker image를 만들도록 한다. 간단한 웹서버를 다음 명령어로 만들도록 한다.
다음과 같이 dockerfile을 만들어서 nginx image를 만들도록 한다. 이미지를 생성하기 전에 dockerfile이 있는 폴더에 index.html을 간단하게 생성 하여 준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim dockerfile]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;Dockerfile 
FROM nginx:latest
MAINTAINER Jake Kim
COPY ./index.html /usr/share/nginx/html
CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nginx&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;-g&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;daemon off;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
EXPOSE 80
EXPOSE 443

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim dockerfile]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; my-nginx:1.0 ./
Sending build context to Docker daemon  3.072kB
Step 1/6 : FROM nginx:latest
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 6678c7c2e56c
Step 2/6 : MAINTAINER Jake Kim
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0a6b329a0499
Removing intermediate container 0a6b329a0499
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 6dc3ec92b539
Step 3/6 : COPY ./index.html /usr/share/nginx/html
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; eafee9a486ce
Step 4/6 : CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nginx&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;-g&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;daemon off;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;32a176f4966a
Removing intermediate container 32a176f4966a
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; a4624c382cfb
Step 5/6 : EXPOSE 80
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;986bd43c69dc
Removing intermediate container 986bd43c69dc
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 0e615bf6918f
Step 6/6 : EXPOSE 443
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;95afcc7af235
Removing intermediate container 95afcc7af235
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 5bf5271f828a
Successfully built 5bf5271f828a
Successfully tagged my-nginx:1.0
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim dockerfile]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images
REPOSITORY                                       TAG                 IMAGE ID            CREATED             SIZE
my-nginx                                         1.0                 5bf5271f828a        6 seconds ago       127MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이미지가 생성 되었음으로 이를 registry로 업로드 하도록 한다.
업로드를 위해서는 먼저 tag를 작성 한 후 push 할 수 있다. tag 작성은 “registry 주소/object namespace/registry 이름:tag” 으로 작성 하여 준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim dockerfile]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker tag my-nginx:1.0 iad.ocir.io/idbkzk6hw0ua/my-nginx:1.0
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim dockerfile]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker push iad.ocir.io/idbkzk6hw0ua/my-nginx:1.0
The push refers to repository &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;iad.ocir.io/idbkzk6hw0ua/my-nginx]
bc5633c583e9: Pushed 
55a77731ed26: Layer already exists 
71f2244bc14d: Layer already exists 
f2cb0ecef392: Layer already exists 
my-nginx: digest: sha256:b96c59a22ddb2f739ec749f1bbae16407bf923ee97abdc87f798c8baecef8cc8 size: 1155
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim dockerfile]&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Push 된 이미지는 Registry 에서 확인 할 수 있다. &lt;br /&gt;
&lt;img src=&quot;/image/ocir/ocir-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;container-생성&quot;&gt;Container 생성&lt;/h1&gt;
&lt;p&gt;이제 Registry를 이용하여 OKE 에 Container를 생성 해 보도록 하겠다. 우선 Registry 접근을 위해 Kubernetes의 secret을 생성 하여 준다.
docker-username은 앞서 사용한 object namespace/사용자이름 으로 작성 하고 docker-passwor는 authtoken 을 넣어준다. 앞서 사용한 authtoken을 알고 있다면 그대로 사용 하면 되고 메모 해 놓은 것이 없다면 추가로 생성 하여 주면 된다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim oke]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create secret docker-registry ocirsecret &lt;span class=&quot;nt&quot;&gt;--docker-server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;iad.ocir.io &lt;span class=&quot;nt&quot;&gt;--docker-username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'idbkzk6hw0ua/oracleidentitycloudservice/****'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--docker-password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'*****'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--docker-email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'***@email.com'&lt;/span&gt;
secret/ocirsecret created
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim oke]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 Pod를 생성 하는 deployment Yaml 파일 (mynginx-deploy.yaml) 을 생성 한다.
container를 생성 하기 위한 image에 Registry 를 지정 하였으며 접근을 위한 Secret 를 작성 하였다.
이미지 이름은 Registry 정보 중 Full Path 정보를 사용 하면 된다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynginx-deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynginx&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;my-nginx&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;iad.ocir.io/idbkzk6hw0ua/my-nginx:1.0&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;imagePullSecrets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ocirsecret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Load Balancer 를 이용한 Service 를 위해 다음과 같이 Service Yaml (mynginx-service.yaml) 파일도 생성 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynginx-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod를 배포 하기 위해 다음과 같이 실행 하여 준다&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim oke]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; mynginx-deploy.yaml 
deployment.apps/mynginx-deployment created
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim oke]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; mynginx-service.yaml 
service/mynginx-service created
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim oke]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get service
NAME              TYPE           CLUSTER-IP      EXTERNAL-IP       PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        AGE
kubernetes        ClusterIP      10.96.0.1       &amp;lt;none&amp;gt;            443/TCP        61m
mynginx-service   LoadBalancer   10.96.131.136   129.213.177.226   80:32605/TCP   40s
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jakekim@JakeKim]&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;외부 IP가 생성 되었음으로 해당 IP 로 접근 하여 보면 다음과 같이 정상 동작 하는 것을 볼 수 있다. &lt;br /&gt;
&lt;img src=&quot;/image/ocir/ocir-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Container Repository Oracle Kubernetes Engine는 Docker를 기반으로 하는 서비스로 컨테이너 이미지를 보관하고 공유 하기 위한 별도 서비스가 필요하다. Oracle cloud를 사용 한 다면 무료로 Container Image Registry를 사용 할 수 있으며 접근을 위한 사용자 관리가 제공 되어 유용하게 활용 할 수 있다. Cloud 계정이 있다면 OCI Console의 개발자 메뉴에서 OCIR (Oracle Cloud Infrastructure Registry)을 볼 수 있다. Oracle Cloud를 사용 하면 홈 리전을 선택 하여 기본 데이터 센터를 선택 하게 되는데 이때 Tenancy의 Object Storage Namespace가 생성 된다. Registry는 해당 Object Storage Namespace (이를 tenancy namespace 라고도 한다)를 이용하여 접근 한다. 우선 이미지가 저장될 Repostory 를 생성 하여 보자.</summary></entry><entry><title type="html">OKE-Basic</title><link href="http://localhost:4000/oke/kubernetes/OKE-basic/" rel="alternate" type="text/html" title="OKE-Basic" /><published>2020-01-10T15:12:00+09:00</published><updated>2020-01-10T15:12:00+09:00</updated><id>http://localhost:4000/oke/kubernetes/OKE-basic</id><content type="html" xml:base="http://localhost:4000/oke/kubernetes/OKE-basic/">&lt;h1 id=&quot;oracle-kubernetes&quot;&gt;Oracle Kubernetes&lt;/h1&gt;
&lt;p&gt;OKE 는 Oracle Kubernetes Engine 으로 Managed Kubernetes 로 별도 설치할 필요 없이 편리하게 사용 할 수 있다는 장점을 제공 한다. 특히 Kubernetes Master 가 3개로 설치 되어 장애 등에 대비 할 수 있는 것이 장점이다. 글을 쓰지 시점에는 지원 되는 버전이 1.14.8, 1.13.5, 1.12.7 이 제공 되고 있다.
별도로 Kubernetes 를 설치 하기 번거롭다면 OKE 를 이용하여 충분히 Kubernetes 를 공부해 볼 수 있다.
OKE 를 구성 하려면 Oracle Cloud 에 로그인 하여 Developer Service 에서 cluster 를 선택 하면 된다.&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Create Cluster 를 클릭 하면 Quick Create 와 Custom Create 옵션이 있다. 네트워크 구성 및 노드 구성을 자동으로 구성 하기 위해 Quick Create 를 선택 하여 준다. 이후 입력 사항은 클러스터의 이름과 Kubernetes 의 버젼, Worker Node 의 네트워크 구성 만 선택 하면 된다. Private 으로 하는 경우 Worker Node 에 Public IP 가 부여 되지 않아 Host 에 직접 접근이 불가능 하다. 그러나 Worker Node 에 대한 보안 측면을 본다면 Private 로 하는 것이 맞으며 Node 접근이 많이 필요 하지 않음으로 Private 로 하면 된다. Shape 와 Node 의 개수는 테스트를 위한 것임으로 VM.Standard.E2.1 로 3 개의 노드를 선택 하도록 하겠다. 리뷰 화면에서는 네트워크 이름과 Pods 에 부여된 네트워크 CIDR 을 볼 수 있다.&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성 버튼을 누르면 Kubernetes Cluster 가 생성 된다.
생성이 완료 되면 Developer Service &amp;gt; Container Cluster 를 들어가 보면 생성된 클러스터와 상태를 볼 수 있다. 생성한 클러스터를 클릭 해 보면 상세한 Kubernetes 의 정보를 볼 수 있다.
이제 Kubernetes 를 관리 하기 위한 Kubectl 을 설치 하여 보자.
순서는 OCICLI 설치, Kubectl 설치로 나뉠수 있다.&lt;/p&gt;

&lt;h1 id=&quot;oci-cli-install&quot;&gt;OCI cli Install&lt;/h1&gt;
&lt;p&gt;사전에 오라클 클라우드 관리 툴인 OCICli 가 설치 되어 있다면 Kubectl 을 바로 설치 하여 주면 된다. 그렇지 않다면 다음 순서로 설치 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MacOS, Linux 환경&lt;/p&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;python3  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/image/kubernetes/kubernetes-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치 경로 및 ocicli 명령어를 Path 넣기 위한 사용자 입력이 필요하며 기본값과 Y 를 선택 하면 된다.
설치 완료 후 oci –version 을 실행 하면 버전 정보를 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Windows 환경&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Powershell 을 Run as Administrator 옵션으로 실행 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Set-ExecutionPolicy RemoteSigned  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; powershell &lt;span class=&quot;nt&quot;&gt;-NoProfile&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ExecutionPolicy&lt;/span&gt; Bypass &lt;span class=&quot;nt&quot;&gt;-Command&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.ps1'))&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;MacOS, Linux 와 마찬가지로 설치되는 경로를 지정 하는 과정이 나온다.&lt;/p&gt;

&lt;h1 id=&quot;oci-cli-config&quot;&gt;OCI cli config&lt;/h1&gt;
&lt;p&gt;다음 과정은 OCI cli 와 사용하고 있는 클라우드 서비스와 연결을 위한 설정이 필요 하다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;macOS, Linux&lt;/p&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;oci setup config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;설치 과정에서 연결을 위한 보안 정보 등이 .oci/config 파일에 저장 된다. 설정 과정은 config 이 저장될 경로 및 User OCID, tenancy OCID, Datacenter 등을 입력 하여야 한다. 
User OCID 는 identity &amp;gt; Users 에서 사용자를 선택 하면 User Information 에서 볼 수 있다&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-4.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Tenancy OCI 는 Administration &amp;gt; tenancy detail 에서 볼 수 있다.&lt;br /&gt;
&lt;img src=&quot;/image/kubernetes/kubernetes-5.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;
인증서를 이용한 연결을 위해 Private key 와 Public key 가 생성이 된다. 특별한 이유가 없으면 기본 이름을 사용하여 생성 하면 비대칭 키가 자동 생성 된다. OCI 에 사용자에 public key 를 인증키로 등록 하여 주면 설정이 완료 된다. identity &amp;gt; Users 에서 사용자를 선택 한 후 API Keys 에서 Add Public Key 를 클릭 하여 Public key 를 등록 하여 주면 된다.
&lt;img src=&quot;/image/kubernetes/kubernetes-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설정이 완료 되었으면 다음 명령어를 실행 하면 Tenancy 이름이 반환 되는 것을 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;oci os ns get  
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;s2&quot;&gt;&quot;data&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;*****&quot;&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;kubectl-install&quot;&gt;Kubectl install&lt;/h1&gt;
&lt;p&gt;oci 설치가 완료되었으며 Kubernetes 관리를 위한 client 툴을 설치하여야 한다. 설치는 다음 문서를 참조 한다
&lt;a href=&quot;https://kubernetes.io/docs/tasks/tools/install-kubectl/&quot;&gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/&lt;/a&gt;
Linux 나 MacOS 에서는 다음과 같이 설치 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-L0&lt;/span&gt; https://storage.googleapis.com/kubernetes-release/release/&lt;span class=&quot;se&quot;&gt;\`&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://storage.googleapis.com/kubernetes-release/release/stable.txt&lt;span class=&quot;se&quot;&gt;\`&lt;/span&gt;/bin/linux/amd64/kubectl  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x ./kubectl  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mv&lt;/span&gt; ./kubectl /usr/local/bin/kubectl  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;OKE 와 kubectl 과 연결을 위해 생성한 OKE cluster 의 OCID 가 필요 하다. 생성한 cluster 의 상세 정보에서 OCID 를 찾을 수 있다.
등록 과정은 다음과 같이 .kube 폴더를 생성 하고 설정 파일을 만드는 과정이다&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;oci ce cluster create-kubeconfig &lt;span class=&quot;nt&quot;&gt;--cluster-id&lt;/span&gt; __Cluster_OCID__ &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config &lt;span class=&quot;nt&quot;&gt;--region&lt;/span&gt; us-ashburn-1 &lt;span class=&quot;nt&quot;&gt;--token-version&lt;/span&gt; 2.0.0  
__Cluster_OCID__ 으로 표기된 부분에 cluster 의 OCID 를 복사하여 주고 region 에는 생성한 cluster 의 지역을 입력 하여 준다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/image/kubernetes/kubernetes-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설정이 완료 되었으면 다음 명령어로 cluster 내의 node 정보를 가져와 보도록 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get node  
NAME        STATUS   ROLES   AGE   VERSION  
10.0.10.2   Ready    node    23d   v1.14.8  
10.0.10.3   Ready    node    23d   v1.14.8  
10.0.10.4   Ready    node    23d   v1.14.8  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;조회 된 내용을 보면 노드의 이름과 상태 운영 중인 시간과 버젼 정보를 볼 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;web-server-container-실행&quot;&gt;Web Server Container 실행&lt;/h1&gt;
&lt;p&gt;이제 간단하게 Nginx 서버를 각 노드에 배치 하고 Public IP 를 부여 해 보도록 하자.&lt;br /&gt;
우선 Nginx 를 이용하여 웹서버를 배포하는 작업을 하도록 하겠다. 이를 위해 다음과 같이 nginx-web-deployment.yaml 파일을 작성 한다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web-deployment&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web&lt;/span&gt;

 &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:latest&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cluster 에 container 구동을 위해서는 다음과 같이 실행 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-deployment.yaml  
deployment.apps/nginx-web-deployment created  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음은 Public IP 를 가지고 서비스를 하기 위한 service 를 설정 해 주어야 한다. 다음 YAML 파일을 생성 하여 배포 하도록 한다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;webserver&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-web&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cluster 에 Service 다음과 같이 배포 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-service.yaml  
service/webserver created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Kubernetes container 의 상태는 다음과 같은 명령어로 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all  
NAME                                        READY   STATUS    RESTARTS   AGE  
pod/nginx-web-deployment-77757cd987-4vhq2   1/1     Running   0          5m11s    
pod/nginx-web-deployment-77757cd987-lqkp5   1/1     Running   0          5m11s  
pod/nginx-web-deployment-77757cd987-plr56   1/1     Running   0          5m11s  

NAME                 TYPE           CLUSTER-IP    EXTERNAL-IP      PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        AGE  
service/kubernetes   ClusterIP      10.96.0.1     &amp;lt;none&amp;gt;           443/TCP        23d  
service/webserver    LoadBalancer   10.96.30.33   129.213.175.32   80:32244/TCP   53s  

NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE  
deployment.apps/nginx-web-deployment   3/3     3            3           5m11s  

NAME                                              DESIRED   CURRENT   READY   AGE  
replicaset.apps/nginx-web-deployment-77757cd987   3         3         3       5m11s  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;External-IP 로 Public IP 가 부여 된 것을 볼 수 있다 해당 IP 로 접근 해 보도록 한다.
&lt;img src=&quot;/image/kubernetes/kubernetes-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;YAMl 파일은 다음 github 에서 받을 수 있다. &lt;a href=&quot;https://github.com/xers989/oke/tree/master/nginx-web&quot;&gt;https://github.com/xers989/oke/tree/master/nginx-web&lt;/a&gt;&lt;br /&gt;
배포한 Container 의 삭제는 다음과 같이 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-service.yaml
service &lt;span class=&quot;s2&quot;&gt;&quot;webserver&quot;&lt;/span&gt; deleted
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx-web-deployment.yaml 
deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;nginx-web-deployment&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OKE 는 Kubernetes Container 구동을 위한 표준을 준수하고 있어 Kubernetes 를 공부 할 때 유용하게 활용 할 수 있으며 Kubernetes 에서 cloud vendor 로 서비스 배포 연계 또한 지원하여 Load Balancer 와 같은 Cloud Vendor 가 제공하는 서비스를 간편하게 설정 구동 할 수 있는 장점이 있다. 이후에 Oracle Cloud 를 활용한 Kubernetes Container 구동을 살펴 보겠다.&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Oracle Kubernetes OKE 는 Oracle Kubernetes Engine 으로 Managed Kubernetes 로 별도 설치할 필요 없이 편리하게 사용 할 수 있다는 장점을 제공 한다. 특히 Kubernetes Master 가 3개로 설치 되어 장애 등에 대비 할 수 있는 것이 장점이다. 글을 쓰지 시점에는 지원 되는 버전이 1.14.8, 1.13.5, 1.12.7 이 제공 되고 있다. 별도로 Kubernetes 를 설치 하기 번거롭다면 OKE 를 이용하여 충분히 Kubernetes 를 공부해 볼 수 있다. OKE 를 구성 하려면 Oracle Cloud 에 로그인 하여 Developer Service 에서 cluster 를 선택 하면 된다.</summary></entry><entry><title type="html">dns-service2</title><link href="http://localhost:4000/edge/dns/dns-service2/" rel="alternate" type="text/html" title="dns-service2" /><published>2020-01-10T14:42:00+09:00</published><updated>2020-01-10T14:42:00+09:00</updated><id>http://localhost:4000/edge/dns/dns-service2</id><content type="html" xml:base="http://localhost:4000/edge/dns/dns-service2/">&lt;h1 id=&quot;traffic-management&quot;&gt;Traffic Management&lt;/h1&gt;
&lt;p&gt;이전 DNS 관련글에서 DNS zone management 를 이용하는 도메인 관리를 소개하였다. 이를 활용 하여 지역별로 웹서버를 설정 하고 사용자 지역에 따라 가까운 서버에서 응답하도록 구성 하여 보겠다. 하나의 도메인에 여러개의 웹서버를 구성하여 트래픽이 분산 처리 되도록 구성 하여 장애에 대한 대처나 성능을 최대화 하기 위한 방안으로 활용이 가능하며 단지 DNS 을 활용한 것으로 빠르게 적용할 수 있다는 것이 장점이다.
그림을 다시 그려 보면 북미와 유럽, 아시아에 각각 웹서버를 배치하고 Edge DNS가 사용자의 위치에 따라 가까운 웹서버로 전달 되도록 경로를 조정 해 주는 것이다. 즉 사용자가 app.service.com 의 주소를 Edge DNS 에 질의하면 가장 가까운 웹서버의 주소를 반환하여 빠르게 응답을 받을 수 있게 된다. 이를 활용하여 글로벌한 Active-Active 서비스 구성을 할 수 있다. 2개 이상의 데이터 센터를 구성 하고 동일한 서비스를 Active-Active 하게 활용하기 위해 글로벌 로드 밸란서를 활용하여 트래픽을 분산하였는데 Edge DNS 를 활용한 다면 쉽게 대체 할 수 있다. 또한 트래픽이 분산되도록 결정을 담당하는 Traffic Management 가 Edge에서 서비스되어 글로벌하게 배포되어 있어 글로벌한 서비스에 활용한 다면 큰 장점을 얻을 수 있다
&lt;img src=&quot;/image/dns-service2/dns-service-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;web-server&quot;&gt;Web Server&lt;/h1&gt;
&lt;p&gt;오라클 클라우드 서비스를 활용하여 서울, 런던, 미국에 웹서버를 구성 하고 사용자별로 어디로 서비스가 전달 되는지 보도록 하겠다. 각 지역별로 웹서버를 구성 하기 위해 오라클 클라우드의 데이터 센터 리전을 확장 하도록 한다. 오라클 클라드에 로그인 하여 상단에 검색 버튼 옆에 데이터 센터를 클릭 하면 리전관리 (Manage Regions) 를 볼 수 있다. 기본 데이터 센터가 Ashburn 으로 하여 London 과 Seoul 을 추가 하도록 한다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 미국 지역에 웹서버를 구성 하도록 한다. 지역을 US East (Ashburn) 으로 선택 한다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-3.png&quot; alt=&quot;&quot; /&gt;
Instance 를 생성 하기 전에 우선 Identity &amp;gt; Compartment 에서 테스트를 위한 Compartment 를 생성 하여 준다.
테스트용 VCN 를 구성해야 한다. 테스트 복적임으로 Quickstart 를 이용하여 바로 생성 하여 준다.
Network &amp;gt; Virtual Cloud Networks &amp;gt; Networking Quickstart &amp;gt; VCN with Internet Connectivity 를 선택하여 네트워크를 구성 한다.&lt;br /&gt;
VCN 은 테스트를 위한 것임으로 테스트 목적에 맞게 구성하고 Compartment 를 꼭 선택 하여 준다. VCN CIDR Block 은 테스트 용도 임으로 10.0.0.0/16 으로 하고 Public Subnet 의 CIDR 은 10.0.0.0/24 하고 Private Subnet 의 CIDR dms 10.0.1.0/24 로 하여 생성 하여 준다. 생성 되는 네트워크는 기본적인 구성으로 Public subnet 와 Private subnet 으로 구성 되며 Public subnet 에 생성 되는 Instance 는 Public IP 를 가지게 된다.&lt;/p&gt;

&lt;p&gt;Compute &amp;gt; Instances 에서 Create Instance 를 한다. 간단히 Docker 를 활용하여 웹서버를 구성할 것임으로 instance Shape 은 VM.Standard.E2.1 정도로 하면 된다.
Show Shape, Network and Storage Options 를 클릭 하여 상세 설정 부분에서 Shape 를 선택 하고 compartment 와 VCN / Subnet 을 선택 한다. Public IP 를 부여 받아야 함으로 Public Subnet 을 선택 한다. 또한 Assign a public IP address 를 선택 하여 준다.
SSH 접근을 위해 비대칭키의 Public key 를 등록 하여 준다.
&lt;img src=&quot;/image/dns-service2/dns-service-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성이 완료 되면 부여된 Public IP 를 이용하여 Instance 에 ssh 접근을 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum update
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-engine
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker opc
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;reboot
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start docker
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;80/tcp
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; ‘This is my Web-Server running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;Ashburn’ &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps 
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
6beeca27476d        httpd               &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;   2 minutes ago       Up About a minute   0.0.0.0:80-&amp;gt;80/tcp   http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;80 으로 서비스를 허용해 주기 위해 Public subnet 의 security list 에 80 을 추가 하여 준다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-5.png&quot; alt=&quot;&quot; /&gt;
브라우저로 접근이 가능한지 테스트 하여 보자&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동일한 작업을 직역을 변경 하여 진행 하여 준다. 
지역 : UK South (London)
VCN : EU_VCN
Docker image 를 생성할 때 웹서버를 구분 하여 보기 위해 index.html 파일을 생성 할 때 다음과 같이 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; ‘This is my Web-Server running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;London’ &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;지역 : South Korea Central (Seoul)
VCN : KR_VCN
Docker image 를 생성할 때 웹서버를 구분 하여 보기 위해 index.html 파일을 생성 할 때 다음과 같이 하여 준다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; ‘This is my Web-Server running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;Seoul’ &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;웹으로 접근이 가능한 지 확인 하여 보자&lt;/p&gt;

&lt;p&gt;London 에 설치한 웹서버&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-7.png&quot; alt=&quot;&quot; /&gt;
Seoul 에 설치한 웹서버&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;traffic-manangement&quot;&gt;Traffic Manangement&lt;/h1&gt;
&lt;p&gt;이제 도메인을 DNS 에 등록 하고 설치 한 웹서버의 IP 를 DNS Record 에 등록 하여 주면 도메인 등록이 완료될 것이다. 그러나 3대의 웹서버를 하나의 도메인으로 연결하고 사용자의 위치 정보에 따라 트래픽이 분배 되도록 조정 하겠다.
우선 이전 포스트에서 처럼 DNS Zone management 에 도메인이 등록이 사전에 필요하다. 등록이 완료 되었으면 Cloud 에 로그인 하여 Network &amp;gt; Traffic management 에서 새로운 Traffic Management Steering Policy 를 생성 한다.
Traffic Management Steering Policy 은 다음 순서로 등록 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Policy Type : 트래픽을 분배 하기 위한 규칙으로 5 가지의 타입이 있으며 이중 하나를 선택 할 수 있다. 
2. Answer Pool : 트래픽 규칙을 생성 할 때 선택 가능 응답으로 웹트래픽이 전달 될 곳을 의미 한다.
3. Steering Rules : Policy Type 에 따라 구성 되며 Type 에 따른 규칙을 실제로 정의 한다.
4. Attach Health Check : 대상 시스템의 작동 유무를 판단 하기 위한 것으로 기존 등록된 것을 선택하거나 새로생성, 없음을 선택 할 수 있다.
5. Attached Domain : Policy 를 적용할 Domain 을 선택
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;policy-type&quot;&gt;Policy Type&lt;/h3&gt;
&lt;p&gt;Geolocation 을 선택 하고 Policy Name 은 WebServerGeolocationSteering 으로 하고 Policy TTL 은 60 초, Maximum Answer count 는 1 로 등록 하여 준다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;answer-pool&quot;&gt;Answer Pool&lt;/h3&gt;
&lt;p&gt;Steering Rule 을 등록 할 때 선택 가능한 응답을 등록 하는 곳으로 등록 된 3개 서버 (Ashburn, London, Seoul) 에서 서비스를 할 것임으로 3개를 Answer Pool 로 등록 하여 준다. 
Pool Name 은 알아보기 쉽게 Ashburn 으로 하고 Answers Name 은 us, type 은 A RDATA 는 Ashburn 웹서버의 IP 를 작성 하여 준다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool&lt;/td&gt;
      &lt;td&gt;Answer Pool Name&lt;/td&gt;
      &lt;td&gt;Answers Name&lt;/td&gt;
      &lt;td&gt;Type&lt;/td&gt;
      &lt;td&gt;RData&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool 1&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
      &lt;td&gt;us&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;IP_ADDRESS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool 2&lt;/td&gt;
      &lt;td&gt;EU&lt;/td&gt;
      &lt;td&gt;eu&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;IP_ADDRESS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Answer Pool 3&lt;/td&gt;
      &lt;td&gt;ASIA&lt;/td&gt;
      &lt;td&gt;asia&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;IP_ADDRESS&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;geolocation-steering-rules&quot;&gt;Geolocation Steering Rules&lt;/h3&gt;
&lt;p&gt;위치에 따른 응답을 선택 하는 것으로 복수개의 규칙을 등록 할 수 있으며 순서대로 실행 된다.
Geolocation 은 대륙 및 나라가 선택 가능 하며 Add Global Catch-All 이 기본으로 선택되게 된다.
시나리오는 유럽과 아프리카는 London 웹서버에서 응답을 주고 백업으로 Ashburn 에서 해주도록 구성 하며 아메리카 대륙은 Ashburn 에서 응답을 주고 London 이 백업 하며 아시아와 호주 지역은 Seoul 에서 응답하고 Ashburn 이 백업 하도록 한다. 그 외에 지역은 Ashburn, Seoul 에서 응답을 주는 것으로 구성 하도록 한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Rule&lt;/th&gt;
      &lt;th&gt;Geolocation&lt;/th&gt;
      &lt;th&gt;Pool Priority 1&lt;/th&gt;
      &lt;th&gt;Pool Priority 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Rule1&lt;/td&gt;
      &lt;td&gt;North America, South America&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
      &lt;td&gt;EU&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rule2&lt;/td&gt;
      &lt;td&gt;Asia, Oceania&lt;/td&gt;
      &lt;td&gt;ASIA&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rule3&lt;/td&gt;
      &lt;td&gt;Europe, Africa&lt;/td&gt;
      &lt;td&gt;EU&lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Catchall&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;US&lt;/td&gt;
      &lt;td&gt;ASIA&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;attach-health-check--attach-domain&quot;&gt;Attach Health Check &amp;amp; Attach domain&lt;/h3&gt;
&lt;p&gt;웹서버를 구성 할 때 헬스체크를 위한 서비스를 등록 하였다면 Health Check 를 등록 하여 응답 불가능 한 상태일 때 다음 서버가 응답을 주도록 구성 할 수 있다. 이번 포스팅에서는 헬스체크를 위한 서비스를 등록 하지 않았음으로 없음을 선택 한다.
Attach Domain 은 이전 포스트에서 등록 한 DNS zone 을 선택 하여 Subdomain 에 app 를 입력 해 준다. 등록이 완료 된다면 app.&lt;em&gt;.&lt;/em&gt; 으로 서비스 될 것 이다.&lt;/p&gt;

&lt;h1 id=&quot;geolocation-test&quot;&gt;Geolocation Test&lt;/h1&gt;
&lt;p&gt;준비가 완료 되었음으로 브라우저의 Geolocation 을 변경 하기 위한 Proxy 를 설치 해준다. firefox 에는 Hoxx 라는 무료 plugin 이 있으니 이를 이용하면 된다. 테스트를 할 때 꼭 브라우저 캐시를 지우고 들어가도록 한다. 우선 국내에서 등록한 도메인으로 접근 하는 경우 웹서버는 Seoul 에서 응답해야 할 것이다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-10.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
이제 위치를 바꾸기 위해 브라우저에 설치된 Hoxx 를 클릭 하고 독일을 선택 한다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-11.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
브라우저의 캐시를 삭제하고 다시 접근 하면 London 에서 응답을 줄 것 이다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-12.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
다시 Hoxx 연결을 끊고 미국을 선택 한 후 브라우저 캐시를 삭제하고 접근하면 Ashburn 웹서버에서 응답을 줄 것이다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service2/dns-service-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자 브라우저의 위치에 따라 가까운 웹서버에서 응답을 주도록 구성을 하였으며 장애 발생시 응답을 줄 수 있는 곳까지 등록 하였음으로 안정적으로 서비스 가능한 구성이 편리 하게 되었다. 지역별 위치한 웹서버에 대한 동기화는 다루지 않았지만 동기화가 된다면 트래픽을 효과적으로 분산 할 수 있음으로 매우 효율적일 것이며 지역별 서버에 해당 지역 언어로 서비스 하로독 구성하여 보다 편리한 서비스를 구성 할 수 있을 것이다.&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Traffic Management 이전 DNS 관련글에서 DNS zone management 를 이용하는 도메인 관리를 소개하였다. 이를 활용 하여 지역별로 웹서버를 설정 하고 사용자 지역에 따라 가까운 서버에서 응답하도록 구성 하여 보겠다. 하나의 도메인에 여러개의 웹서버를 구성하여 트래픽이 분산 처리 되도록 구성 하여 장애에 대한 대처나 성능을 최대화 하기 위한 방안으로 활용이 가능하며 단지 DNS 을 활용한 것으로 빠르게 적용할 수 있다는 것이 장점이다. 그림을 다시 그려 보면 북미와 유럽, 아시아에 각각 웹서버를 배치하고 Edge DNS가 사용자의 위치에 따라 가까운 웹서버로 전달 되도록 경로를 조정 해 주는 것이다. 즉 사용자가 app.service.com 의 주소를 Edge DNS 에 질의하면 가장 가까운 웹서버의 주소를 반환하여 빠르게 응답을 받을 수 있게 된다. 이를 활용하여 글로벌한 Active-Active 서비스 구성을 할 수 있다. 2개 이상의 데이터 센터를 구성 하고 동일한 서비스를 Active-Active 하게 활용하기 위해 글로벌 로드 밸란서를 활용하여 트래픽을 분산하였는데 Edge DNS 를 활용한 다면 쉽게 대체 할 수 있다. 또한 트래픽이 분산되도록 결정을 담당하는 Traffic Management 가 Edge에서 서비스되어 글로벌하게 배포되어 있어 글로벌한 서비스에 활용한 다면 큰 장점을 얻을 수 있다</summary></entry><entry><title type="html">dns-service</title><link href="http://localhost:4000/edge/dns/dns-service/" rel="alternate" type="text/html" title="dns-service" /><published>2020-01-02T15:02:00+09:00</published><updated>2020-01-02T15:02:00+09:00</updated><id>http://localhost:4000/edge/dns/dns-service</id><content type="html" xml:base="http://localhost:4000/edge/dns/dns-service/">&lt;h1 id=&quot;edge-서비스&quot;&gt;Edge 서비스&lt;/h1&gt;
&lt;p&gt;오라클은 2016년 11월 DYN 이란 업체를 인수 하면서 Edge 서비스를 시작 하였다.
현재는 Oracle Cloud 서비스에 통합 되어 Cloud Console 에서 사용 가능하다.&lt;/p&gt;

&lt;p&gt;Edge 서비스는 서울을 포함하여 글로벌 하게 분포 되어 있으며 사용자의 네트웍에서 가장 가까운 Edge 서비스를 통해서 Web Application 에 접근 하는 구조 이다. 이러한 구조로 글로벌 하게 일정 수준의 성능을 보여주는 Web Application 을 만들 수 있으며 장애 등에 빠르게 대응이 가능하게 된다.&lt;/p&gt;

&lt;p&gt;아래 그림에 OCI DNS 는 Oracle 이 제공 하는 Edge 서비스로 사용자가 app.service.com 에 접근 하게 되면 Recursive Server 는 OCI DNS 에 DNS 질의를 하고 OCI DNS 는 Origin Server 즉 app.service.com 의 주소를 반환 하여 사용자가 app.service.com 에 접근 할 수 있게 한다.
이때 질의를 처리하는 OCI DNS 는 사용자와 가장 가까운 곳에 있는 곳에서 응답을 주며 사용자 위치나 app.service.com 의 상태에 따라 주소를 달리 하여 일정 수준의 성능을 보여 주도록 할 수 있다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림을 다시 그려 보면 북미와 유럽, 아시아에 각각 Origin 서버를 배치하고 해당 지역의 Edge 에서 app.service.com 를 서비스 한다면 각 지역의 Edge 는 가장 가까운 곳의 Origin 서버에서 서비스가 진행 되도록 주소를 반환 할 수 있다. 각 app.service.com 간의 동기화는 다른 문제이지만 이를 통해 글로벌 하게 Web Application 을 각 지역에 배치 하고 해당 지역 사용자는 가까운 Web Application 을 사용하도록 하여 성능을 확보 할 수 있으며 Asia 혹은 EU 의 서버에 장애가 난 경우 서비스가 가능한 NA 로 서비스가 되도록 경로를 조정 할 수 있다. 보통 DNS 를 이용한 조정이 60 분 가량이 소요 되지만 OCI DNS 는 30 초 가량으로 빠르게 배포 될 수 있으며 REST API 를 제공 하여 서비스 이상을 감지하고 자동으로 DNS 를 조정 할 수 있는 구조를 만들수 있다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;oracle-dns&quot;&gt;Oracle DNS&lt;/h1&gt;
&lt;p&gt;실습을 위해서는 우선 도메인이 필요 하며 도메인 관리 업체에 Domain Name Server 를 OCI 에서 진행 할 것이라는 것을 알려 주어야 한다.
OCI 콜솔에 로그인 한 후 Neworking 메뉴에서 DNS Zone Management 를 선택 한다.
DNS Zone 은 도메인 이름을 관리 해주는 솔루션으로 사용할 도메인을 등록 하여 OCI DNS 에서 해당 주소를 서비스 하도록 설정 하여야 한다. 이를 위해 Creae Zone 을 한다.
Zone 생성은 매우 간단하게 Zone Type 을 Primary 로 하고 Zone Name 에 사용할 도메일 이름을 작성 해 준다. (참고로 DNS Zone 은 Oracle Compartment 에 의해 관리 됨으로 생성 하기 전에 꼭 Compartment 를 선택 하여야 한다)&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성이 완료 되면 OCI DNS 의 네임서버 정보를 볼 수 있게 된다. 이제 DNS 제공자에게 이 네임서버를 이용해서 서비스 할 것이라는 것을 알리는 과정이 필요하다&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Godaddy 의 경우 도메인 관리에서 DNS Management 에서 Nameservers 를 변경 하는 것이 가능하다. NameServer 를 Use my own nameservers 로 선택 하고 OCI DNS 에서 제공 하는 Name Server 를 입력 하여 준다&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;web-application&quot;&gt;Web Application&lt;/h1&gt;
&lt;p&gt;도메인 등록이 완료 되었으니 간단히 웹서버를 만들어서 서비스를 하여 DNS 가 정상 동작하는 지 볼것이다. OCI 에 Docker 를 이용하여 Apache 서버를 기동 시킬 것이다. 구매한 도메인이 iamhub.site 임으로 edge.iamhub.site 로 만들 것이다.
우선 클라우드에 Public IP 는 VM 을 구성하고 docker 를 설치 하여 보자.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# yum install docker-engine  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# usermod -aG docker opc  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# systemctl start docker&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;포트는 80 으로 할 것임으로 방화벽과 클라우드 Security List 에 80 이 허용 되도록 변경 하여 준다 (Linux7 기준으로 아래 두개 중 하나를 해주면 된다)&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# firewall-cmd --add-service=http&lt;/span&gt;
or
&lt;span class=&quot;c&quot;&gt;# firewall-cmd --add-port=80/tcp  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 docker 를 이용하여 Apache Web server 를 구동 시켜 보자.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;html  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'This is my Web-Server running on docker'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./html/index.html  
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/opc/html/:/usr/local/apache2/htdocs/ &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; http httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 Docker 가 구동이 되었다면 다음 처럼 Wep Page 가 보여 질 것이다.
&lt;img src=&quot;/image/dns-service/dns-service-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 DNS Zone management 에서 DNS 를 둥록 하여 볼 것이다. iamhub.site 라는 Domain 을 소유 하고 있어 app.iamhub.site 로 등록 하여 볼 것이다.
Cloud 에 로그인 하여 Networking &amp;gt; DNS Zone Management 에서 등록 한 zone 을 선택 한 후 Records 를 선택 하면 DNS 를 추가 할 수 있다. app.iamhub.site 라는 A 타입을 추가 하여 주고 대상 시스템의 IP 를 등록 해 주면 된다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장 후에 내용을 Edge 로 배포 하기 위해 publish changes 를 해 주어야 한다. 배포는 몇 초 이내로 완료 된다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배포가 완료 되면 도메인 이름으로 서버 접근이 가능 하다.&lt;br /&gt;
&lt;img src=&quot;/image/dns-service/dns-service-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 포스트에서는 웹서버를 서로 다른 지역에 두고 가까운 곳에서 서비스가 되도록 구성하여 보겠다&lt;/p&gt;</content><author><name>Jake Kim</name></author><summary type="html">Edge 서비스 오라클은 2016년 11월 DYN 이란 업체를 인수 하면서 Edge 서비스를 시작 하였다. 현재는 Oracle Cloud 서비스에 통합 되어 Cloud Console 에서 사용 가능하다.</summary></entry></feed>