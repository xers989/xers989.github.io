<!DOCTYPE html><html lang="en-GB"><head> <!-- General meta --><meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --><meta name="generator" content="Jekyll v3.8.5" /><meta property="og:title" content="Kubernetes-오케스트레이션과 Pod배포" /><meta name="author" content="Jake Kim" /><meta property="og:locale" content="en_US" /><meta name="description" content="Kubernetes 구조 및 배포 Kubernetes 구조 Kubernetes는 컨테이너를 멀티 호스트 환경에서 효율적으로 운영하기 위한 도구로 컨테이너의 시작, 정지 및 네트워크, 컨테이너 구동에 대한 스케쥴링을 제공하는 툴(컨테이너 오케스트레이션)이다. 중요한 개념은 desired state 즉 원하는 상태를 유지시켜주는 개념이다. 주기적으로 사용자가 원하는 상태 값고 현재 운영되고 있는 값을 체크 하여 그 차이를 비교 하고 차이 나는 부분을 처리 해주는 것이다. 즉 컨테이너가 3개를 생성 운영 하도록 하였을 때 어떠한 사유에 의해 컨테이너 1개가 정지 되어 현재 2개 컨테이만 운영 중이라면 Kubernetes는 차이나는 1개에 대해 처리하여 줌으로 목표 하고 있던 3개 컨테이너를 유지 시켜 주는 것이다. 이러한 컨테이너 관리를 위해 기본 구조는 관리 부분인 Master (혹은 Control Plane) 와 컨테이너가 실행 되어 운영되는 Node (혹은 Data Plane)로 기본 구성이 된다. Master 의 경우 모든 요청을 처리하기 위한 API Server (kube-apiserver), 데이터를 저장 하고 있는 저장소 (ETCD), Pod의 배치를 제어하는 스케쥴러와 클러스터를 감시 하는 컨트롤러로 구성 된다." /><meta property="og:description" content="Kubernetes 구조 및 배포 Kubernetes 구조 Kubernetes는 컨테이너를 멀티 호스트 환경에서 효율적으로 운영하기 위한 도구로 컨테이너의 시작, 정지 및 네트워크, 컨테이너 구동에 대한 스케쥴링을 제공하는 툴(컨테이너 오케스트레이션)이다. 중요한 개념은 desired state 즉 원하는 상태를 유지시켜주는 개념이다. 주기적으로 사용자가 원하는 상태 값고 현재 운영되고 있는 값을 체크 하여 그 차이를 비교 하고 차이 나는 부분을 처리 해주는 것이다. 즉 컨테이너가 3개를 생성 운영 하도록 하였을 때 어떠한 사유에 의해 컨테이너 1개가 정지 되어 현재 2개 컨테이만 운영 중이라면 Kubernetes는 차이나는 1개에 대해 처리하여 줌으로 목표 하고 있던 3개 컨테이너를 유지 시켜 주는 것이다. 이러한 컨테이너 관리를 위해 기본 구조는 관리 부분인 Master (혹은 Control Plane) 와 컨테이너가 실행 되어 운영되는 Node (혹은 Data Plane)로 기본 구성이 된다. Master 의 경우 모든 요청을 처리하기 위한 API Server (kube-apiserver), 데이터를 저장 하고 있는 저장소 (ETCD), Pod의 배치를 제어하는 스케쥴러와 클러스터를 감시 하는 컨트롤러로 구성 된다." /><link rel="canonical" href="http://localhost:4000/oke/kubernetes/Kubernetes-basic/" /><meta property="og:url" content="http://localhost:4000/oke/kubernetes/Kubernetes-basic/" /><meta property="og:site_name" content="Jake Kim" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-16T16:05:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kubernetes-오케스트레이션과 Pod배포" /><meta name="twitter:site" content="@xers9" /><meta name="twitter:creator" content="@Jake Kim" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/oke/kubernetes/Kubernetes-basic/"},"url":"http://localhost:4000/oke/kubernetes/Kubernetes-basic/","author":{"@type":"Person","name":"Jake Kim"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/kyudong.kim.png"},"name":"Jake Kim"},"headline":"Kubernetes-오케스트레이션과 Pod배포","dateModified":"2021-03-16T16:05:00+09:00","datePublished":"2021-03-16T16:05:00+09:00","description":"Kubernetes 구조 및 배포 Kubernetes 구조 Kubernetes는 컨테이너를 멀티 호스트 환경에서 효율적으로 운영하기 위한 도구로 컨테이너의 시작, 정지 및 네트워크, 컨테이너 구동에 대한 스케쥴링을 제공하는 툴(컨테이너 오케스트레이션)이다. 중요한 개념은 desired state 즉 원하는 상태를 유지시켜주는 개념이다. 주기적으로 사용자가 원하는 상태 값고 현재 운영되고 있는 값을 체크 하여 그 차이를 비교 하고 차이 나는 부분을 처리 해주는 것이다. 즉 컨테이너가 3개를 생성 운영 하도록 하였을 때 어떠한 사유에 의해 컨테이너 1개가 정지 되어 현재 2개 컨테이만 운영 중이라면 Kubernetes는 차이나는 1개에 대해 처리하여 줌으로 목표 하고 있던 3개 컨테이너를 유지 시켜 주는 것이다. 이러한 컨테이너 관리를 위해 기본 구조는 관리 부분인 Master (혹은 Control Plane) 와 컨테이너가 실행 되어 운영되는 Node (혹은 Data Plane)로 기본 구성이 된다. Master 의 경우 모든 요청을 처리하기 위한 API Server (kube-apiserver), 데이터를 저장 하고 있는 저장소 (ETCD), Pod의 배치를 제어하는 스케쥴러와 클러스터를 감시 하는 컨트롤러로 구성 된다.","@type":"BlogPosting","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><title>Kubernetes-오케스트레이션과 Pod배포</title><link rel="icon" type="image/png" href="?s=16" sizes="16x16"><link rel="icon" type="image/png" href="?s=32" sizes="32x32"><link rel="icon" type="image/png" href="?s=96" sizes="96x96"><link rel="shortcut icon" href=""><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jake Kim" /></head><body> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="height: 0; position: absolute"> <symbol id="flickr" viewBox="0 0 16 16"><path d="M0 8c0 2.05 1.662 3.71 3.71 3.71 2.05 0 3.713-1.66 3.713-3.71S5.76 4.29 3.71 4.29C1.663 4.29 0 5.95 0 8zm8.577 0c0 2.05 1.662 3.71 3.712 3.71C14.337 11.71 16 10.05 16 8s-1.662-3.71-3.71-3.71c-2.05 0-3.713 1.66-3.713 3.71z"/></symbol> <symbol id="github" viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.582 0 8c0 3.535 2.292 6.533 5.47 7.59.4.075.547-.172.547-.385 0-.19-.007-.693-.01-1.36-2.226.483-2.695-1.073-2.695-1.073-.364-.924-.89-1.17-.89-1.17-.725-.496.056-.486.056-.486.803.056 1.225.824 1.225.824.714 1.223 1.873.87 2.33.665.072-.517.278-.87.507-1.07-1.777-.2-3.644-.888-3.644-3.953 0-.873.31-1.587.823-2.147-.083-.202-.358-1.015.077-2.117 0 0 .672-.215 2.2.82.638-.178 1.323-.266 2.003-.27.68.004 1.364.092 2.003.27 1.527-1.035 2.198-.82 2.198-.82.437 1.102.163 1.915.08 2.117.513.56.823 1.274.823 2.147 0 3.073-1.87 3.75-3.653 3.947.287.246.543.735.543 1.48 0 1.07-.01 1.933-.01 2.195 0 .215.144.463.55.385C13.71 14.53 16 11.534 16 8c0-4.418-3.582-8-8-8"/></symbol> <symbol id="linkedin" viewBox="0 0 16 16"><path d="M13.632 13.635h-2.37V9.922c0-.886-.018-2.025-1.234-2.025-1.235 0-1.424.964-1.424 1.96v3.778h-2.37V6H8.51V7.04h.03c.318-.6 1.092-1.233 2.247-1.233 2.4 0 2.845 1.58 2.845 3.637v4.188zM3.558 4.955c-.762 0-1.376-.617-1.376-1.377 0-.758.614-1.375 1.376-1.375.76 0 1.376.617 1.376 1.375 0 .76-.617 1.377-1.376 1.377zm1.188 8.68H2.37V6h2.376v7.635zM14.816 0H1.18C.528 0 0 .516 0 1.153v13.694C0 15.484.528 16 1.18 16h13.635c.652 0 1.185-.516 1.185-1.153V1.153C16 .516 15.467 0 14.815 0z" fill-rule="nonzero"/></symbol> <symbol id="rss" viewBox="0 0 16 16"><path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194 11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.985 2.194-2.196 2.194C.984 16 0 15.017 0 13.806c0-1.21.983-2.195 2.194-2.195zM10.606 16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"/></symbol> <symbol id="twitter" viewBox="0 0 16 16"><path d="M16 3.038c-.59.26-1.22.437-1.885.517.677-.407 1.198-1.05 1.443-1.816-.634.375-1.337.648-2.085.795-.598-.638-1.45-1.036-2.396-1.036-1.812 0-3.282 1.468-3.282 3.28 0 .258.03.51.085.75C5.152 5.39 2.733 4.084 1.114 2.1.83 2.583.67 3.147.67 3.75c0 1.14.58 2.143 1.46 2.732-.538-.017-1.045-.165-1.487-.41v.04c0 1.59 1.13 2.918 2.633 3.22-.276.074-.566.114-.865.114-.21 0-.416-.02-.617-.058.418 1.304 1.63 2.253 3.067 2.28-1.124.88-2.54 1.404-4.077 1.404-.265 0-.526-.015-.783-.045 1.453.93 3.178 1.474 5.032 1.474 6.038 0 9.34-5 9.34-9.338 0-.143-.004-.284-.01-.425.64-.463 1.198-1.04 1.638-1.7z" fill-rule="nonzero"/></symbol> <symbol id="email" viewBox="0 0 16 11"><path fill-rule="evenodd" d="M1.33 0h13.34L8 5 1.33 0zM16 0v11H0V0l8 6 8-6z"/></symbol> </svg><header class="header"><div class="container"> <a class="logo" href="http://localhost:4000" title="Jake Kim"><img src="/assets/img/kyudong.kim.png" alt="Jake Kim logo"/></a><nav class="nav nav--header"><ul class="list list--nav"><li class="item item--nav"><a href="/">Home</a></li><li class="item item--nav"><a href="/blog/">Blog</a></li></ul></nav></div></header><!--collect all blog tags http://longqian.me/2017/02/09/github-jekyll-tag/ --><main class="main container"><article class="content typeset"><h1>Kubernetes-오케스트레이션과 Pod배포</h1><small class="small post-meta"> <span class="label label--category"> </span> <time datetime="2021-03-16T16:05:00+09:00" class="time"> 16 Mar 2021 </time> </small><div style="padding-bottom: 3%"><h1 id="kubernetes-구조-및-배포">Kubernetes 구조 및 배포</h1><h4 id="kubernetes-구조">Kubernetes 구조</h4><p>Kubernetes는 컨테이너를 멀티 호스트 환경에서 효율적으로 운영하기 위한 도구로 컨테이너의 시작, 정지 및 네트워크, 컨테이너 구동에 대한 스케쥴링을 제공하는 툴(컨테이너 오케스트레이션)이다. 중요한 개념은 desired state 즉 원하는 상태를 유지시켜주는 개념이다. 주기적으로 사용자가 원하는 상태 값고 현재 운영되고 있는 값을 체크 하여 그 차이를 비교 하고 차이 나는 부분을 처리 해주는 것이다. 즉 컨테이너가 3개를 생성 운영 하도록 하였을 때 어떠한 사유에 의해 컨테이너 1개가 정지 되어 현재 2개 컨테이만 운영 중이라면 Kubernetes는 차이나는 1개에 대해 처리하여 줌으로 목표 하고 있던 3개 컨테이너를 유지 시켜 주는 것이다.<br /> 이러한 컨테이너 관리를 위해 기본 구조는 관리 부분인 Master (혹은 Control Plane) 와 컨테이너가 실행 되어 운영되는 Node (혹은 Data Plane)로 기본 구성이 된다. Master 의 경우 모든 요청을 처리하기 위한 API Server (kube-apiserver), 데이터를 저장 하고 있는 저장소 (ETCD), Pod의 배치를 제어하는 스케쥴러와 클러스터를 감시 하는 컨트롤러로 구성 된다. <br /> <img src="/image/kubernetes2/kubernetes02.png" alt="" width="90%" height="90%" /></p><h4 id="api-server">API Server</h4><p>리소스 관리를 위한 서버로 REST API를 제공 한다. 사용자가 접근 할 수 있는 유일한 창구로 모든 명령은 API Server를 통해서만 가능 하다. 사용자의 요청을 받아서 유효성을 검증하며 수평 확장이 가능 한 구조이다. <br /> 제공되는 API는 /{group}/{version}/namespaces/{namespace}/{resource} 형태이다. API가 동작 하는 구조는 다음과 같으며 사용자 요청을 받아서 인증 및 인가 처리를 한 후 Admission 처리, Validation이 처리 된다. <br /> <img src="/image/kubernetes2/kubernetes03.png" alt="" width="100%" height="100%" /> <br /> Mutation Admission은 사용자 요청을 Hooking하여 플러그 인을 이용한 확장 기능을 적용 할 수 있게 한다. 요청한 API의 매니페스트 내용 중 특정한 값으로 변경하는 작업을 수행하한다. 간단한 예가 Pod를 배포 할 때 사용 할 수 있는 리소스에 제한을 두기 위해 LimitRange를 줄 수 있는데 이를 적용 하지 않은 요청이 온 경우 중간에 이를 가로 채서 기본값으로 채워 주는 역할을 할 수 있다. Object Schema Validation은 객체의 값이 올바르게 입력 되었는지 검증하게 된다. Validation Admission은 사용자 지정 정책에 따라 사용자 요청을 최종 허용/거부를 결정하여 주는 역할을 한다. Admission의 경우 클러스터 버전이 1.16 이상에서 사용하는 것을 권장한다.<br /> 모든 과정이 통과된 경우 데이터는 데이터 베이스에 저장 된다. 데이터 베이스 영역은 가상화 레이어로 제공됨으로 다양한 종류의 데이터베이스를 사용 할 수 있다. 데이터는 Key-Value 형태로 저장 되며 ETCD를 사용 하는 경우가 많다.</p><h4 id="etcd">ETCD</h4><p>고가용성을 제공하는 Key-Value 저장소로 Kubernetes에서 필요한 데이터를 저정하는 데이터 베이스이다. 분산형 합의 기반 시스템으로 클러스터 형태로 복수개로 인스턴스를 구성하거나 API Server와 분리된 노드에 설치 할 수 있다.</p><h4 id="scheduler">Scheduler</h4><p>클러스터 내부에 자원 할당이 가능한 노드 중 알맞은 노드를 선택 하여 자원을 배포해 주는 역할을 한다.</p><h4 id="kube-controller-manager">Kube-Controller-Manager</h4><p>노드에 실행되고 있는 Pod를 관리하는 컨트롤러로 노드 컨트롤러, 레플리케이션 컨트롤러, 엔드포인트 컨트롤러, 서비스 어카운트, 토큰 컨트롤러를 포함하고 있다.</p><h4 id="cloud-controller-manager">Cloud-Controller-Manager</h4><p>클라우드 자원를 사용하기 위한 컨트롤러로 클라우드 플랫폼과 상호 작동하기 위해 클라우드 서비스 제공자 전용 컨트롤러로 Kube-Controller-Manager와 구분되어 사용 된다. 노드, 라우드, 서비스 컨트롤러가 있다. (서비스 제공자에 따라 다를 수 있다)</p><h4 id="pod">Pod</h4><p>Pod는 Kubernetes가 유지 시켜 주기 위한 기본 단위로 최소 1개의 컨테이너를 포함하는 구조로 되어 있다. 아래 그림 처럼 Pod는 한개 이상의 컨테이너와 스토리지, 네트워크로 구성된 단위라고 보면 된다. <br /> <img src="/image/kubernetes2/kubernetes01.png" alt="" width="70%" height="70%" /> <br /> Pod를 배포 하기 위한 매니페스트는 다음 내용을 포함 한다.</p><div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">www</span>
 <span class="na">labels</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">method</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">spec</span><span class="pi">:</span>
 <span class="na">containers</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
   <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
   <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
   <span class="na">volumeMounts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/etc/www</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">www-data</span>
   <span class="na">resources</span><span class="pi">:</span>
    <span class="na">requests</span><span class="pi">:</span>
     <span class="na">cpu</span><span class="pi">:</span> <span class="s">800m</span>
     <span class="na">memory</span><span class="pi">:</span> <span class="s">8G</span>
 <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">OnFailure</span>
 <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">www-data</span>
</code></pre></div></div><p>metadata 항목은 이름과 레이블을 지정 할 수 있다.(레이블은 이후 Pod를 선택 하기 위한 검색값으로 사용된다) spec 항목에 Pod에 들어갈 컨테이너에 대한 정보로 nginx (dockerhub에서 검색 하며 버젼을 명기 할 수 있다), 오픈하는 포트 정보 및 마운트 관련 정보를 가지고 있다. resources 항목에 컨테이너에 할당할 리소스를 설정 하는 것으로 최대 CPU, Memory 요청하는 CPU, Memory 값을 설정 할 수 있다. 요청 하는 리소스가 배치 가능한 노드가 선택 되어 배치 되며 노드별 가능한 용량을 넘어서는 자원이 요청 되는 경우 오류가 발생 된다. Pod 가 배치된 노드의 터미널에 접속 하여 컨테이너 프로세스 정보(docker ps)를 보면 다음 과 같은 내용을 볼 수 있다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>opc@oke ~]<span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID  IMAGE   COMMAND                 CREATED         STATUS   PORTS NAMES
115555731b61  nginx   <span class="s2">"/docker-entrypoint.…"</span>  21 hours ago    Up 21 hours    k8s_nginx_www_default_35ca8888-0f55-4af3-98ef-7d1d787be985_0
71f8d996b150  ap-seoul-1.ocir.io/axoxdievda5j/oke-public-pause-amd64  <span class="s2">"/pause"</span>  22 hours ago  Up 22 hours    k8s_POD_www_default_35ca8888-0f55-4af3-98ef-7d1d787be985_0
...
</code></pre></div></div><p>Pod 가 배치 되면 지정된 컨테이너(nginx) 뿐만 아니라 Pause 컨테이너가 하나 추가 배포된 것을 볼 수 있다. Pause 컨테이너는 Pod내에 존재하는 컨테이너의 부모와 같은 역할을 한다. 해당 Pod의 환경 정보를 컨테이너와 공유하여 주며 라이프 사이클에 대한 관리 등을 하여 준다. Pod가 배포 될 때 Pause 컨테이너가 배포되면서 노드 머신에 네임스페이스를 생성하고 mnt, pid,net,ipc 등 네임스페이스 정보를 이후 생성 될 컨테이너와 공유 한다. 이러한 이유로 Pod내의 컨테이너는 다른 노드에 분리되어 설치 될 수 없다. Pod의 구조는 다음과 같다고 볼 수 있다. <br /> <img src="/image/kubernetes2/kubernetes04.png" alt="" width="70%" height="70%" /></p></div></article><aside class="aside typeset"><h4>Related Posts</h4><ul class="list list--posts"><li class="item item--post"><div class="typeset"><h4><a href="/network/peering/LocalPeering/">동일한 리전에 생성된 VNC 간 네트워크 연결 하기 (Local Peering)</a></h4><small class="small post-meta"> <time datetime="2021-03-13T22:00:00+09:00" class="time"> 13 Mar 2021 </time> </small> <span><br/><h1 id="oracle-vcn-local-peering">Oracle VCN Local Peering</h1><p>오라클 클라우드는 VCN을 이용하여 네트워크를...</span></div></li><li class="item item--post"><div class="typeset"><h4><a href="/edge/dns/dns-service3/">DNS 이전하기</a></h4><small class="small post-meta"> <time datetime="2021-03-12T15:02:00+09:00" class="time"> 12 Mar 2021 </time> </small> <span><br/><h1 id="oracle-dns-management">Oracle DNS Management</h1><p>오라클 DNS는 클라우드 기반 도메인 네임서비스로...</span></div></li><li class="item item--post"><div class="typeset"><h4><a href="/edge/waf/sqlinjection/WAF-SQLBlindInjection/">WAF SQL Blind Injection</a></h4><small class="small post-meta"> <time datetime="2020-03-13T13:00:00+09:00" class="time"> 13 Mar 2020 </time> </small> <span><br/><h1 id="owasp-sql-blind-injection">OWASP SQL Blind Injection</h1><p>이전의 SQL Injection 공격은 SQL을...</span></div></li></ul><a class="button" href="/feed.xml" title="Subscribe" >Subscribe&nbsp; <svg class="icon" role="img"><use xlink:href="#rss"></use></svg></a><nav class="nav nav--social"><h6>Contact me:</h6><a class="link" target="_blank" href="https://github.com/xers989" title="github"><svg class="icon" role="img"><use xlink:href="#github"></use></svg></a> <a class="link" target="_blank" href="https://www.linkedin.com/in/kyudong-kim-80778033/" title="linkedin"><svg class="icon" role="img"><use xlink:href="#linkedin"></use></svg></a></nav></aside></main><script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-93479534-1', 'auto'); ga('send', 'pageview'); </script><footer class="footer"><div class="container"><nav class="nav nav--footer"><ul class="list list--nav"><li class="item item--nav"> <a href="https://alembic.darn.es/">Adopted Alembic Theme</a></li></ul></nav><div class="copyright typeset"> <small style="color:white;">&copy; Jake Kim 2021</small></div></div></footer></body><link rel="stylesheet" href="/assets/styles.css"><link href="https://fonts.googleapis.com/css?family=Roboto:300" rel="stylesheet"></html>
